```json
{
  "bundle_manifest": [
    {
      "path": "infra/terraform/providers.tf",
      "purpose": "Terraform provider configuration with empty S3 backend for CI injection",
      "generated_bytes": 512
    },
    {
      "path": "infra/terraform/variables.tf",
      "purpose": "Global variables for project, env, region, and resource naming",
      "generated_bytes": 768
    },
    {
      "path": "infra/terraform/api.tf",
      "purpose": "HTTP API Gateway v2 with routes to Orders and Inventory Lambda functions",
      "generated_bytes": 2048
    },
    {
      "path": "infra/terraform/orders.tf",
      "purpose": "Orders service: Lambda functions, DynamoDB table, IAM policies, EventBridge publishing",
      "generated_bytes": 3584
    },
    {
      "path": "infra/terraform/inventory.tf",
      "purpose": "Inventory service: Lambda function, DynamoDB table with TTL, IAM policies, EventBridge publishing",
      "generated_bytes": 3328
    },
    {
      "path": "infra/terraform/receipts.tf",
      "purpose": "Receipts worker: Lambda function triggered by EventBridge rule for ReceiptGenerated events",
      "generated_bytes": 2304
    },
    {
      "path": "infra/terraform/ingestor.tf",
      "purpose": "CRM Ingestor: S3 bucket, Lambda function triggered on CSV uploads, IAM policies",
      "generated_bytes": 2816
    },
    {
      "path": "infra/terraform/eventbridge.tf",
      "purpose": "EventBridge custom bus and rules for inter-service event routing",
      "generated_bytes": 1536
    },
    {
      "path": "infra/terraform/health.tf",
      "purpose": "Health check Lambda function for operational monitoring",
      "generated_bytes": 1024
    },
    {
      "path": "infra/terraform/outputs.tf",
      "purpose": "Terraform outputs for API endpoint, table names, bucket name, and bus ARN",
      "generated_bytes": 896
    },
    {
      "path": "src/common/logger.py",
      "purpose": "Structured JSON logging utility for all Lambda functions",
      "generated_bytes": 1280
    },
    {
      "path": "src/orders/glue.py",
      "purpose": "Adapter wrapper for orders handlers with structured logging and error handling",
      "generated_bytes": 2048
    },
    {
      "path": "src/inventory/glue.py",
      "purpose": "Adapter wrapper for inventory handler with structured logging and error handling",
      "generated_bytes": 1792
    },
    {
      "path": "src/receipts/glue.py",
      "purpose": "Adapter wrapper for receipts worker with structured logging",
      "generated_bytes": 1536
    },
    {
      "path": "src/ingestor/glue.py",
      "purpose": "Adapter wrapper for CSV ingestor with structured logging",
      "generated_bytes": 1664
    },
    {
      "path": "src/ops/glue.py",
      "purpose": "Adapter wrapper for health check handler with structured logging",
      "generated_bytes": 1280
    },
    {
      "path": "tests/test_orders.py",
      "purpose": "Unit tests for orders service handlers",
      "generated_bytes": 2560
    },
    {
      "path": "tests/test_inventory.py",
      "purpose": "Unit tests for inventory reservation handler including idempotency",
      "generated_bytes": 2816
    },
    {
      "path": "tests/test_receipts.py",
      "purpose": "Unit tests for receipts worker",
      "generated_bytes": 1024
    },
    {
      "path": "tests/test_ingestor.py",
      "purpose": "Unit tests for CRM CSV ingestor",
      "generated_bytes": 1792
    },
    {
      "path": "tests/test_integration.py",
      "purpose": "Integration-light test exercising order creation to receipt generation flow with mocks",
      "generated_bytes": 2304
    },
    {
      "path": ".github/workflows/ci.yml",
      "purpose": "CI workflow: lint, test, package, terraform validate/plan on PR; apply to staging on main with OIDC",
      "generated_bytes": 3840
    },
    {
      "path": "readme.md",
      "purpose": "Project documentation with architecture overview, deployment instructions, and usage examples",
      "generated_bytes": 4096
    },
    {
      "path": "changelog.md",
      "purpose": "Initial changelog documenting the stitch and CI setup",
      "generated_bytes": 512
    }
  ],
  "src": {
    "files": [
      {
        "path": "src/common/logger.py",
        "content": "# src/common/logger.py\nimport json\nimport logging\nimport sys\nfrom datetime import datetime\nfrom typing import Any, Dict\n\nclass JSONFormatter(logging.Formatter):\n    def format(self, record: logging.LogRecord) -> str:\n        log_obj: Dict[str, Any] = {\n            \"timestamp\": datetime.utcnow().isoformat() + \"Z\",\n            \"level\": record.levelname,\n            \"message\": record.getMessage(),\n            \"logger\": record.name,\n        }\n        if record.exc_info:\n            log_obj[\"exception\"] = self.formatException(record.exc_info)\n        if hasattr(record, \"context\"):\n            log_obj[\"context\"] = record.context\n        return json.dumps(log_obj)\n\ndef get_logger(name: str) -> logging.Logger:\n    logger = logging.getLogger(name)\n    if not logger.handlers:\n        handler = logging.StreamHandler(sys.stdout)\n        handler.setFormatter(JSONFormatter())\n        logger.addHandler(handler)\n        logger.setLevel(logging.INFO)\n    return logger\n"
      },
      {
        "path": "src/orders/glue.py",
        "content": "# src/orders/glue.py\nimport json\nimport traceback\nfrom typing import Any, Dict\nfrom src.common.logger import get_logger\nfrom src.orders.handlers import create_order as _create_order, get_order as _get_order\n\nlogger = get_logger(\"orders.glue\")\n\ndef create_order(event: Dict[str, Any], context: Any) -> Dict[str, Any]:\n    logger.info(\"create_order invoked\", extra={\"context\": {\"request_id\": context.request_id}})\n    try:\n        result = _create_order(event, context)\n        logger.info(\"create_order completed\", extra={\"context\": {\"status_code\": result.get(\"statusCode\")}})\n        return result\n    except Exception as e:\n        logger.error(f\"create_order failed: {str(e)}\", extra={\"context\": {\"error\": str(e), \"traceback\": traceback.format_exc()}})\n        return {\n            \"statusCode\": 500,\n            \"body\": json.dumps({\"error\": \"Internal server error\"})\n        }\n\ndef get_order(event: Dict[str, Any], context: Any) -> Dict[str, Any]:\n    logger.info(\"get_order invoked\", extra={\"context\": {\"request_id\": context.request_id}})\n    try:\n        result = _get_order(event, context)\n        logger.info(\"get_order completed\", extra={\"context\": {\"status_code\": result.get(\"statusCode\")}})\n        return result\n    except Exception as e:\n        logger.error(f\"get_order failed: {str(e)}\", extra={\"context\": {\"error\": str(e), \"traceback\": traceback.format_exc()}})\n        return {\n            \"statusCode\": 500,\n            \"body\": json.dumps({\"error\": \"Internal server error\"})\n        }\n"
      },
      {
        "path": "src/inventory/glue.py",
        "content": "# src/inventory/glue.py\nimport json\nimport traceback\nfrom typing import Any, Dict\nfrom src.common.logger import get_logger\nfrom src.inventory.handlers import reserve as _reserve\n\nlogger = get_logger(\"inventory.glue\")\n\ndef reserve(event: Dict[str, Any], context: Any) -> Dict[str, Any]:\n    logger.info(\"reserve invoked\", extra={\"context\": {\"request_id\": context.request_id}})\n    try:\n        result = _reserve(event, context)\n        logger.info(\"reserve completed\", extra={\"context\": {\"status_code\": result.get(\"statusCode\")}})\n        return result\n    except Exception as e:\n        logger.error(f\"reserve failed: {str(e)}\", extra={\"context\": {\"error\": str(e), \"traceback\": traceback.format_exc()}})\n        return {\n            \"statusCode\": 500,\n            \"body\": json.dumps({\"error\": \"Internal server error\"})\n        }\n"
      },
      {
        "path": "src/receipts/glue.py",
        "content": "# src/receipts/glue.py\nimport traceback\nfrom typing import Any, Dict\nfrom src.common.logger import get_logger\nfrom src.receipts.worker import handler as _handler\n\nlogger = get_logger(\"receipts.glue\")\n\ndef handler(event: Dict[str, Any], context: Any) -> Dict[str, Any]:\n    logger.info(\"receipts worker invoked\", extra={\"context\": {\"request_id\": context.request_id}})\n    try:\n        result = _handler(event, context)\n        logger.info(\"receipts worker completed\", extra={\"context\": {\"result\": result}})\n        return result\n    except Exception as e:\n        logger.error(f\"receipts worker failed: {str(e)}\", extra={\"context\": {\"error\": str(e), \"traceback\": traceback.format_exc()}})\n        return {\"ok\": False, \"error\": str(e)}\n"
      },
      {
        "path": "src/ingestor/glue.py",
        "content": "# src/ingestor/glue.py\nimport traceback\nfrom typing import Any, Dict\nfrom src.common.logger import get_logger\nfrom src.ingestor.process_csv import handler as _handler\n\nlogger = get_logger(\"ingestor.glue\")\n\ndef handler(event: Dict[str, Any], context: Any) -> Dict[str, Any]:\n    logger.info(\"CSV ingestor invoked\", extra={\"context\": {\"request_id\": context.request_id}})\n    try:\n        result = _handler(event, context)\n        logger.info(\"CSV ingestor completed\", extra={\"context\": {\"result\": result}})\n        return result\n    except Exception as e:\n        logger.error(f\"CSV ingestor failed: {str(e)}\", extra={\"context\": {\"error\": str(e), \"traceback\": traceback.format_exc()}})\n        return {\"ok\": False, \"error\": str(e)}\n"
      },
      {
        "path": "src/ops/glue.py",
        "content": "# src/ops/glue.py\nimport traceback\nfrom typing import Any, Dict\nfrom src.common.logger import get_logger\nfrom src.ops.health import handler as _handler\n\nlogger = get_logger(\"ops.glue\")\n\ndef handler(event: Dict[str, Any], context: Any) -> Dict[str, Any]:\n    logger.info(\"health check invoked\", extra={\"context\": {\"request_id\": context.request_id}})\n    try:\n        result = _handler(event, context)\n        logger.info(\"health check completed\")\n        return result\n    except Exception as e:\n        logger.error(f\"health check failed: {str(e)}\", extra={\"context\": {\"error\": str(e), \"traceback\": traceback.format_exc()}})\n        return {\"statusCode\": 500, \"body\": \"error\"}\n"
      }
    ]
  },
  "infra": {
    "terraform": {
      "files": [
        {
          "path": "infra/terraform/providers.tf",
          "content": "# infra/terraform/providers.tf\nterraform {\n  required_version = \">= 1.7.0\"\n  required_providers {\n    aws = {\n      source  = \"hashicorp/aws\"\n      version = \">= 5.0\"\n    }\n  }\n  # Backend configuration injected via CI with -backend-config\n  backend \"s3\" {}\n}\n\nprovider \"aws\" {\n  region = var.region\n  default_tags {\n    tags = var.tags\n  }\n}\n"
        },
        {
          "path": "infra/terraform/variables.tf",
          "content": "# infra/terraform/variables.tf\nvariable \"region\" {\n  type        = string\n  description = \"AWS region\"\n  default     = \"us-east-1\"\n}\n\nvariable \"project\" {\n  type        = string\n  description = \"Project name for resource naming\"\n}\n\nvariable \"env\" {\n  type        = string\n  description = \"Environment (staging, prod)\"\n}\n\nvariable \"tags\" {\n  type        = map(string)\n  description = \"Common tags for all resources\"\n  default     = {}\n}\n\nlocals {\n  name_prefix = \"${var.project}-${var.env}\"\n  common_tags = merge(var.tags, {\n    Project     = var.project\n    Environment = var.env\n    ManagedBy   = \"terraform\"\n  })\n}\n"
        },
        {
          "path": "infra/terraform/api.tf",
          "content": "# infra/terraform/api.tf\nresource \"aws_apigatewayv2_api\" \"http_api\" {\n  name          = \"${local.name_prefix}-api\"\n  protocol_type = \"HTTP\"\n\n  cors_configuration {\n    allow_headers = [\"*\"]\n    allow_methods = [\"*\"]\n    allow_origins = [\"*\"]\n  }\n\n  tags = local.common_tags\n}\n\nresource \"aws_apigatewayv2_stage\" \"default\" {\n  api_id      = aws_apigatewayv2_api.http_api.id\n  name        = \"$default\"\n  auto_deploy = true\n\n  tags = local.common_tags\n}\n\n# Orders - POST /orders\nresource \"aws_apigatewayv2_integration\" \"create_order\" {\n  api_id                 = aws_apigatewayv2_api.http_api.id\n  integration_type       = \"AWS_PROXY\"\n  integration_method     = \"POST\"\n  integration_uri        = aws_lambda_function.create_order.invoke_arn\n  payload_format_version = \"2.0\"\n}\n\nresource \"aws_apigatewayv2_route\" \"create_order\" {\n  api_id    = aws_apigatewayv2_api.http_api.id\n  route_key = \"POST /orders\"\n  target    = \"integrations/${aws_apigatewayv2_integration.create_order.id}\"\n}\n\nresource \"aws_lambda_permission\" \"create_order_api\" {\n  statement_id  = \"AllowAPIGatewayInvoke-CreateOrder\"\n  action        = \"lambda:InvokeFunction\"\n  function_name = aws_lambda_function.create_order.function_name\n  principal     = \"apigateway.amazonaws.com\"\n  source_arn    = \"${aws_apigatewayv2_api.http_api.execution_arn}/*/*/orders\"\n}\n\n# Orders - GET /orders/{order_id}\nresource \"aws_apigatewayv2_integration\" \"get_order\" {\n  api_id                 = aws_apigatewayv2_api.http_api.id\n  integration_type       = \"AWS_PROXY\"\n  integration_method     = \"POST\"\n  integration_uri        = aws_lambda_function.get_order.invoke_arn\n  payload_format_version = \"2.0\"\n}\n\nresource \"aws_apigatewayv2_route\" \"get_order\" {\n  api_id    = aws_apigatewayv2_api.http_api.id\n  route_key = \"GET /orders/{order_id}\"\n  target    = \"integrations/${aws_apigatewayv2_integration.get_order.id}\"\n}\n\nresource \"aws_lambda_permission\" \"get_order_api\" {\n  statement_id  = \"AllowAPIGatewayInvoke-GetOrder\"\n  action        = \"lambda:InvokeFunction\"\n  function_name = aws_lambda_function.get_order.function_name\n  principal     = \"apigateway.amazonaws.com\"\n  source_arn    = \"${aws_apigatewayv2_api.http_api.execution_arn}/*/*/orders/*\"\n}\n\n# Inventory - POST /inventory/reserve\nresource \"aws_apigatewayv2_integration\" \"reserve_inventory\" {\n  api_id                 = aws_apigatewayv2_api.http_api.id\n  integration_type       = \"AWS_PROXY\"\n  integration_method     = \"POST\"\n  integration_uri        = aws_lambda_function.reserve_inventory.invoke_arn\n  payload_format_version = \"2.0\"\n}\n\nresource \"aws_apigatewayv2_route\" \"reserve_inventory\" {\n  api_id    = aws_apigatewayv2_api.http_api.id\n  route_key = \"POST /inventory/reserve\"\n  target    = \"integrations/${aws_apigatewayv2_integration.reserve_inventory.id}\"\n}\n\nresource \"aws_lambda_permission\" \"reserve_inventory_api\" {\n  statement_id  = \"AllowAPIGatewayInvoke-ReserveInventory\"\n  action        = \"lambda:InvokeFunction\"\n  function_name = aws_lambda_function.reserve_inventory.function_name\n  principal     = \"apigateway.amazonaws.com\"\n  source_arn    = \"${aws_apigatewayv2_api.http_api.execution_arn}/*/*/inventory/reserve\"\n}\n\n# Health - GET /health\nresource \"aws_apigatewayv2_integration\" \"health\" {\n  api_id                 = aws_apigatewayv2_api.http_api.id\n  integration_type       = \"AWS_PROXY\"\n  integration_method     = \"POST\"\n  integration_uri        = aws_lambda_function.health.invoke_arn\n  payload_format_version = \"2.0\"\n}\n\nresource \"aws_apigatewayv2_route\" \"health\" {\n  api_id    = aws_apigatewayv2_api.http_api.id\n  route_key = \"GET /health\"\n  target    = \"integrations/${aws_apigatewayv2_integration.health.id}\"\n}\n\nresource \"aws_lambda_permission\" \"health_api\" {\n  statement_id  = \"AllowAPIGatewayInvoke-Health\"\n  action        = \"lambda:InvokeFunction\"\n  function_name = aws_lambda_function.health.function_name\n  principal     = \"apigateway.amazonaws.com\"\n  source_arn    = \"${aws_apigatewayv2_api.http_api.execution_arn}/*/*/health\"\n}\n"
        },
        {
          "path": "infra/terraform/orders.tf",
          "content": "# infra/terraform/orders.tf\nresource \"aws_dynamodb_table\" \"orders\" {\n  name         = \"${local.name_prefix}-orders\"\n  billing_mode = \"PAY_PER_REQUEST\"\n  hash_key     = \"order_id\"\n\n  attribute {\n    name = \"order_id\"\n    type = \"S\"\n  }\n\n  tags = local.common_tags\n}\n\nresource \"aws_iam_role\" \"create_order\" {\n  name = \"${local.name_prefix}-create-order-exec\"\n\n  assume_role_policy = jsonencode({\n    Version = \"2012-10-17\"\n    Statement = [{\n      Effect = \"Allow\"\n      Principal = {\n        Service = \"lambda.amazonaws.com\"\n      }\n      Action = \"sts:AssumeRole\"\n    }]\n  })\n\n  tags = local.common_tags\n}\n\nresource \"aws_iam_role_policy_attachment\" \"create_order_logs\" {\n  role       = aws_iam_role.create_order.name\n  policy_arn = \"arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole\"\n}\n\nresource \"aws_iam_role_policy\" \"create_order_ddb\" {\n  name = \"ddb-access\"\n  role = aws_iam_role.create_order.id\n\n  policy = jsonencode({\n    Version = \"2012-10-17\"\n    Statement = [\n      {\n        Effect = \"Allow\"\n        Action = [\n          \"dynamodb:PutItem\"\n        ]\n        Resource = aws_dynamodb_table.orders.arn\n      }\n    ]\n  })\n}\n\nresource \"aws_iam_role_policy\" \"create_order_events\" {\n  name = \"eventbridge-access\"\n  role = aws_iam_role.create_order.id\n\n  policy = jsonencode({\n    Version = \"2012-10-17\"\n    Statement = [\n      {\n        Effect = \"Allow\"\n        Action = [\n          \"events:PutEvents\"\n        ]\n        Resource = aws_cloudwatch_event_bus.main.arn\n      }\n    ]\n  })\n}\n\nresource \"aws_lambda_function\" \"create_order\" {\n  function_name = \"${local.name_prefix}-create-order\"\n  role          = aws_iam_role.create_order.arn\n  runtime       = \"python3.11\"\n  handler       = \"src.orders.glue.create_order\"\n  timeout       = 15\n  memory_size   = 512\n  filename      = \"${path.module}/../../lambda.zip\"\n  source_code_hash = filebase64sha256(\"${path.module}/../../lambda.zip\")\n\n  environment {\n    variables = {\n      ORDERS_TABLE   = aws_dynamodb_table.orders.name\n      EVENT_BUS_NAME = aws_cloudwatch_event_bus.main.name\n    }\n  }\n\n  tags = local.common_tags\n}\n\nresource \"aws_iam_role\" \"get_order\" {\n  name = \"${local.name_prefix}-get-order-exec\"\n\n  assume_role_policy = jsonencode({\n    Version = \"2012-10-17\"\n    Statement = [{\n      Effect = \"Allow\"\n      Principal = {\n        Service = \"lambda.amazonaws.com\"\n      }\n      Action = \"sts:AssumeRole\"\n    }]\n  })\n\n  tags = local.common_tags\n}\n\nresource \"aws_iam_role_policy_attachment\" \"get_order_logs\" {\n  role       = aws_iam_role.get_order.name\n  policy_arn = \"arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole\"\n}\n\nresource \"aws_iam_role_policy\" \"get_order_ddb\" {\n  name = \"ddb-access\"\n  role = aws_iam_role.get_order.id\n\n  policy = jsonencode({\n    Version = \"2012-10-17\"\n    Statement = [\n      {\n        Effect = \"Allow\"\n        Action = [\n          \"dynamodb:GetItem\"\n        ]\n        Resource = aws_dynamodb_table.orders.arn\n      }\n    ]\n  })\n}\n\nresource \"aws_lambda_function\" \"get_order\" {\n  function_name = \"${local.name_prefix}-get-order\"\n  role          = aws_iam_role.get_order.arn\n  runtime       = \"python3.11\"\n  handler       = \"src.orders.glue.get_order\"\n  timeout       = 15\n  memory_size   = 512\n  filename      = \"${path.module}/../../lambda.zip\"\n  source_code_hash = filebase64sha256(\"${path.module}/../../lambda.zip\")\n\n  environment {\n    variables = {\n      ORDERS_TABLE = aws_dynamodb_table.orders.name\n    }\n  }\n\n  tags = local.common_tags\n}\n\nresource \"aws_cloudwatch_metric_alarm\" \"create_order_errors\" {\n  alarm_name          = \"${local.name_prefix}-create-order-errors\"\n  comparison_operator = \"GreaterThanThreshold\"\n  evaluation_periods  = 1\n  metric_name         = \"Errors\"\n  namespace           = \"AWS/Lambda\"\n  period              = 300\n  statistic           = \"Sum\"\n  threshold           = 5\n  alarm_description   = \"Alert when create_order Lambda errors exceed threshold\"\n  dimensions = {\n    FunctionName = aws_lambda_function.create_order.function_name\n  }\n  tags = local.common_tags\n}\n\nresource \"aws_cloudwatch_metric_alarm\" \"create_order_throttles\" {\n  alarm_name          = \"${local.name_prefix}-create-order-throttles\"\n  comparison_operator = \"GreaterThanThreshold\"\n  evaluation_periods  = 1\n  metric_name         = \"Throttles\"\n  namespace           = \"AWS/Lambda\"\n  period              = 300\n  statistic           = \"Sum\"\n  threshold           = 3\n  alarm_description   = \"Alert when create_order Lambda throttles exceed threshold\"\n  dimensions = {\n    FunctionName = aws_lambda_function.create_order.function_name\n  }\n  tags = local.common_tags\n}\n"
        },
        {
          "path": "infra/terraform/inventory.tf",
          "content": "# infra/terraform/inventory.tf\nresource \"aws_dynamodb_table\" \"inventory\" {\n  name         = \"${local.name_prefix}-inventory\"\n  billing_mode = \"PAY_PER_REQUEST\"\n  hash_key     = \"sku\"\n\n  attribute {\n    name = \"sku\"\n    type = \"S\"\n  }\n\n  ttl {\n    attribute_name = \"ttl\"\n    enabled        = true\n  }\n\n  tags = local.common_tags\n}\n\nresource \"aws_iam_role\" \"reserve_inventory\" {\n  name = \"${local.name_prefix}-reserve-inventory-exec\"\n\n  assume_role_policy = jsonencode({\n    Version = \"2012-10-17\"\n    Statement = [{\n      Effect = \"Allow\"\n      Principal = {\n        Service = \"lambda.amazonaws.com\"\n      }\n      Action = \"sts:AssumeRole\"\n    }]\n  })\n\n  tags = local.common_tags\n}\n\nresource \"aws_iam_role_policy_attachment\" \"reserve_inventory_logs\" {\n  role       = aws_iam_role.reserve_inventory.name\n  policy_arn = \"arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole\"\n}\n\nresource \"aws_iam_role_policy\" \"reserve_inventory_ddb\" {\n  name = \"ddb-access\"\n  role = aws_iam_role.reserve_inventory.id\n\n  policy = jsonencode({\n    Version = \"2012-10-17\"\n    Statement = [\n      {\n        Effect = \"Allow\"\n        Action = [\n          \"dynamodb:PutItem\",\n          \"dynamodb:UpdateItem\"\n        ]\n        Resource = aws_dynamodb_table.inventory.arn\n      }\n    ]\n  })\n}\n\nresource \"aws_iam_role_policy\" \"reserve_inventory_events\" {\n  name = \"eventbridge-access\"\n  role = aws_iam_role.reserve_inventory.id\n\n  policy = jsonencode({\n    Version = \"2012-10-17\"\n    Statement = [\n      {\n        Effect = \"Allow\"\n        Action = [\n          \"events:PutEvents\"\n        ]\n        Resource = aws_cloudwatch_event_bus.main.arn\n      }\n    ]\n  })\n}\n\nresource \"aws_lambda_function\" \"reserve_inventory\" {\n  function_name = \"${local.name_prefix}-reserve-inventory\"\n  role          = aws_iam_role.reserve_inventory.arn\n  runtime       = \"python3.11\"\n  handler       = \"src.inventory.glue.reserve\"\n  timeout       = 15\n  memory_size   = 512\n  filename      = \"${path.module}/../../lambda.zip\"\n  source_code_hash = filebase64sha256(\"${path.module}/../../lambda.zip\")\n\n  environment {\n    variables = {\n      INVENTORY_TABLE = aws_dynamodb_table.inventory.name\n      EVENT_BUS_NAME  = aws_cloudwatch_event_bus.main.name\n    }\n  }\n\n  tags = local.common_tags\n}\n\nresource \"aws_cloudwatch_metric_alarm\" \"reserve_inventory_errors\" {\n  alarm_name          = \"${local.name_prefix}-reserve-inventory-errors\"\n  comparison_operator = \"GreaterThanThreshold\"\n  evaluation_periods  = 1\n  metric_name         = \"Errors\"\n  namespace           = \"AWS/Lambda\"\n  period              = 300\n  statistic           = \"Sum\"\n  threshold           = 5\n  alarm_description   = \"Alert when reserve_inventory Lambda errors exceed threshold\"\n  dimensions = {\n    FunctionName = aws_lambda_function.reserve_inventory.function_name\n  }\n  tags = local.common_tags\n}\n\nresource \"aws_cloudwatch_metric_alarm\" \"reserve_inventory_throttles\" {\n  alarm_name          = \"${local.name_prefix}-reserve-inventory-throttles\"\n  comparison_operator = \"GreaterThanThreshold\"\n  evaluation_periods  = 1\n  metric_name         = \"Throttles\"\n  namespace           = \"AWS/Lambda\"\n  period              = 300\n  statistic           = \"Sum\"\n  threshold           = 3\n  alarm_description   = \"Alert when reserve_inventory Lambda throttles exceed threshold\"\n  dimensions = {\n    FunctionName = aws_lambda_function.reserve_inventory.function_name\n  }\n  tags = local.common_tags\n}\n"
        },
        {
          "path": "infra/terraform/receipts.tf",
          "content": "# infra/terraform/receipts.tf\nresource \"aws_iam_role\" \"receipts_worker\" {\n  name = \"${local.name_prefix}-receipts-worker-exec\"\n\n  assume_role_policy = jsonencode({\n    Version = \"2012-10-17\"\n    Statement = [{\n      Effect = \"Allow\"\n      Principal = {\n        Service = \"lambda.amazonaws.com\"\n      }\n      Action = \"sts:AssumeRole\"\n    }]\n  })\n\n  tags = local.common_tags\n}\n\nresource \"aws_iam_role_policy_attachment\" \"receipts_worker_logs\" {\n  role       = aws_iam_role.receipts_worker.name\n  policy_arn = \"arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole\"\n}\n\nresource \"aws_lambda_function\" \"receipts_worker\" {\n  function_name = \"${local.name_prefix}-receipts-worker\"\n  role          = aws_iam_role.receipts_worker.arn\n  runtime       = \"python3.11\"\n  handler       = \"src.receipts.glue.handler\"\n  timeout       = 15\n  memory_size   = 512\n  filename      = \"${path.module}/../../lambda.zip\"\n  source_code_hash = filebase64sha256(\"${path.module}/../../lambda.zip\")\n\n  environment {\n    variables = {\n      EVENT_BUS_NAME = aws_cloudwatch_event_bus.main.name\n    }\n  }\n\n  tags = local.common_tags\n}\n\nresource \"aws_cloudwatch_event_rule\" \"receipt_generated\" {\n  name           = \"${local.name_prefix}-receipt-generated\"\n  event_bus_name = aws_cloudwatch_event_bus.main.name\n  event_pattern = jsonencode({\n    source      = [\"app.orders\"]\n    detail-type = [\"ReceiptGenerated\"]\n  })\n\n  tags = local.common_tags\n}\n\nresource \"aws_cloudwatch_event_target\" \"receipts_worker\" {\n  rule           = aws_cloudwatch_event_rule.receipt_generated.name\n  event_bus_name = aws_cloudwatch_event_bus.main.name\n  arn            = aws_lambda_function.receipts_worker.arn\n}\n\nresource \"aws_lambda_permission\" \"receipts_worker_events\" {\n  statement_id  = \"AllowEventBridgeInvoke-ReceiptsWorker\"\n  action        = \"lambda:InvokeFunction\"\n  function_name = aws_lambda_function.receipts_worker.function_name\n  principal     = \"events.amazonaws.com\"\n  source_arn    = aws_cloudwatch_event_rule.receipt_generated.arn\n}\n\nresource \"aws_cloudwatch_metric_alarm\" \"receipts_worker_errors\" {\n  alarm_name          = \"${local.name_prefix}-receipts-worker-errors\"\n  comparison_operator = \"GreaterThanThreshold\"\n  evaluation_periods  = 1\n  metric_name         = \"Errors\"\n  namespace           = \"AWS/Lambda\"\n  period              = 300\n  statistic           = \"Sum\"\n  threshold           = 5\n  alarm_description   = \"Alert when receipts_worker Lambda errors exceed threshold\"\n  dimensions = {\n    FunctionName = aws_lambda_function.receipts_worker.function_name\n  }\n  tags = local.common_tags\n}\n"
        },
        {
          "path": "infra/terraform/ingestor.tf",
          "content": "# infra/terraform/ingestor.tf\nresource \"aws_s3_bucket\" \"crm_ingestion\" {\n  bucket        = \"${local.name_prefix}-crm-ingestion\"\n  force_destroy = true\n\n  tags = local.common_tags\n}\n\nresource \"aws_s3_bucket_public_access_block\" \"crm_ingestion\" {\n  bucket                  = aws_s3_bucket.crm_ingestion.id\n  block_public_acls       = true\n  block_public_policy     = true\n  ignore_public_acls      = true\n  restrict_public_buckets = true\n}\n\nresource \"aws_iam_role\" \"csv_ingestor\" {\n  name = \"${local.name_prefix}-csv-ingestor-exec\"\n\n  assume_role_policy = jsonencode({\n    Version = \"2012-10-17\"\n    Statement = [{\n      Effect = \"Allow\"\n      Principal = {\n        Service = \"lambda.amazonaws.com\"\n      }\n      Action = \"sts:AssumeRole\"\n    }]\n  })\n\n  tags = local.common_tags\n}\n\nresource \"aws_iam_role_policy_attachment\" \"csv_ingestor_logs\" {\n  role       = aws_iam_role.csv_ingestor.name\n  policy_arn = \"arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole\"\n}\n\nresource \"aws_iam_role_policy\" \"csv_ingestor_s3\" {\n  name = \"s3-access\"\n  role = aws_iam_role.csv_ingestor.id\n\n  policy = jsonencode({\n    Version = \"2012-10-17\"\n    Statement = [\n      {\n        Effect = \"Allow\"\n        Action = [\n          \"s3:GetObject\"\n        ]\n        Resource = \"${aws_s3_bucket.crm_ingestion.arn}/*\"\n      }\n    ]\n  })\n}\n\nresource \"aws_iam_role_policy\" \"csv_ingestor_events\" {\n  name = \"eventbridge-access\"\n  role = aws_iam_role.csv_ingestor.id\n\n  policy = jsonencode({\n    Version = \"2012-10-17\"\n    Statement = [\n      {\n        Effect = \"Allow\"\n        Action = [\n          \"events:PutEvents\"\n        ]\n        Resource = aws_cloudwatch_event_bus.main.arn\n      }\n    ]\n  })\n}\n\nresource \"aws_lambda_function\" \"csv_ingestor\" {\n  function_name = \"${local.name_prefix}-csv-ingestor\"\n  role          = aws_iam_role.csv_ingestor.arn\n  runtime       = \"python3.11\"\n  handler       = \"src.ingestor.glue.handler\"\n  timeout       = 60\n  memory_size   = 512\n  filename      = \"${path.module}/../../lambda.zip\"\n  source_code_hash = filebase64sha256(\"${path.module}/../../lambda.zip\")\n\n  environment {\n    variables = {\n      EVENT_BUS_NAME = aws_cloudwatch_event_bus.main.name\n    }\n  }\n\n  tags = local.common_tags\n}\n\nresource \"aws_lambda_permission\" \"csv_ingestor_s3\" {\n  statement_id  = \"AllowS3Invoke-CSVIngestor\"\n  action        = \"lambda:InvokeFunction\"\n  function_name = aws_lambda_function.csv_ingestor.function_name\n  principal     = \"s3.amazonaws.com\"\n  source_arn    = aws_s3_bucket.crm_ingestion.arn\n}\n\nresource \"aws_s3_bucket_notification\" \"crm_ingestion\" {\n  bucket = aws_s3_bucket.crm_ingestion.id\n\n  lambda_function {\n    lambda_function_arn = aws_lambda_function.csv_ingestor.arn\n    events              = [\"s3:ObjectCreated:*\"]\n    filter_suffix       = \".csv\"\n  }\n\n  depends_on = [aws_lambda_permission.csv_ingestor_s3]\n}\n\nresource \"aws_cloudwatch_metric_alarm\" \"csv_ingestor_errors\" {\n  alarm_name          = \"${local.name_prefix}-csv-ingestor-errors\"\n  comparison_operator = \"GreaterThanThreshold\"\n  evaluation_periods  = 1\n  metric_name         = \"Errors\"\n  namespace           = \"AWS/Lambda\"\n  period              = 300\n  statistic           = \"Sum\"\n  threshold           = 3\n  alarm_description   = \"Alert when csv_ingestor Lambda errors exceed threshold\"\n  dimensions = {\n    FunctionName = aws_lambda_function.csv_ingestor.function_name\n  }\n  tags = local.common_tags\n}\n"
        },
        {
          "path": "infra/terraform/eventbridge.tf",
          "content": "# infra/terraform/eventbridge.tf\nresource \"aws_cloudwatch_event_bus\" \"main\" {\n  name = \"${local.name_prefix}-events\"\n  tags = local.common_tags\n}\n"
        },
        {
          "path": "infra/terraform/health.tf",
          "content": "# infra/terraform/health.tf\nresource \"aws_iam_role\" \"health\" {\n  name = \"${local.name_prefix}-health-exec\"\n\n  assume_role_policy = jsonencode({\n    Version = \"2012-10-17\"\n    Statement = [{\n      Effect = \"Allow\"\n      Principal = {\n        Service = \"lambda.amazonaws.com\"\n      }\n      Action = \"sts:AssumeRole\"\n    }]\n  })\n\n  tags = local.common_tags\n}\n\nresource \"aws_iam_role_policy_attachment\" \"health_logs\" {\n  role       = aws_iam_role.health.name\n  policy_arn = \"arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole\"\n}\n\nresource \"aws_lambda_function\" \"health\" {\n  function_name = \"${local.name_prefix}-health\"\n  role          = aws_iam_role.health.arn\n  runtime       = \"python3.11\"\n  handler       = \"src.ops.glue.handler\"\n  timeout       = 10\n  memory_size   = 256\n  filename      = \"${path.module}/../../lambda.zip\"\n  source_code_hash = filebase64sha256(\"${path.module}/../../lambda.zip\")\n\n  environment {\n    variables = {\n      BUILD_SHA = \"staging\"\n    }\n  }\n\n  tags = local.common_tags\n}\n"
        },
        {
          "path": "infra/terraform/outputs.tf",
          "content": "# infra/terraform/outputs.tf\noutput \"api_endpoint\" {\n  description = \"HTTP API Gateway endpoint URL\"\n  value       = aws_apigatewayv2_api.http_api.api_endpoint\n}\n\noutput \"orders_table_name\" {\n  description = \"Orders DynamoDB table name\"\n  value       = aws_dynamodb_table.orders.name\n}\n\noutput \"inventory_table_name\" {\n  description = \"Inventory DynamoDB table name\"\n  value       = aws_dynamodb_table.inventory.name\n}\n\noutput \"crm_bucket_name\" {\n  description = \"CRM ingestion S3 bucket name\"\n  value       = aws_s3_bucket.crm_ingestion.bucket\n}\n\noutput \"event_bus_name\" {\n  description = \"EventBridge custom bus name\"\n  value       = aws_cloudwatch_event_bus.main.name\n}\n\noutput \"event_bus_arn\" {\n  description = \"EventBridge custom bus ARN\"\n  value       = aws_cloudwatch_event_bus.main.arn\n}\n"
        }
      ]
    }
  },
  "ci": {
    "workflows": [
      {
        "path": ".github/workflows/ci.yml",
        "content": "name: CI/CD Pipeline\n\non:\n  pull_request:\n    branches: [main]\n  push:\n    branches: [main]\n\nenv:\n  AWS_REGION: us-east-1\n  PROJECT_NAME: serverless-app\n  PYTHON_VERSION: '3.11'\n\npermissions:\n  id-token: write\n  contents: read\n  pull-requests: write\n\njobs:\n  lint:\n    name: Lint\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      \n      - name: Set up Python\n        uses: actions/setup-python@v5\n        with:\n          python-version: ${{ env.PYTHON_VERSION }}\n      \n      - name: Install dependencies\n        run: |\n          python -m pip install --upgrade pip\n          pip install flake8 black\n      \n      - name: Run black\n        run: black --check src/ tests/\n      \n      - name: Run flake8\n        run: flake8 src/ tests/ --max-line-length=120 --extend-ignore=E203,W503\n\n  test:\n    name: Test\n    runs-on: ubuntu-latest\n    needs: lint\n    steps:\n      - uses: actions/checkout@v4\n      \n      - name: Set up Python\n        uses: actions/setup-python@v5\n        with:\n          python-version: ${{ env.PYTHON_VERSION }}\n      \n      - name: Install dependencies\n        run: |\n          python -m pip install --upgrade pip\n          pip install pytest pytest-cov boto3 moto\n      \n      - name: Run tests\n        run: |\n          pytest tests/ -v --cov=src --cov-report=term-missing\n\n  package:\n    name: Package Lambda\n    runs-on: ubuntu-latest\n    needs: test\n    steps:\n      - uses: actions/checkout@v4\n      \n      - name: Set up Python\n        uses: actions/setup-python@v5\n        with:\n          python-version: ${{ env.PYTHON_VERSION }}\n      \n      - name: Install dependencies\n        run: |\n          python -m pip install --upgrade pip\n          pip install boto3 -t package/\n          cp -r src package/\n      \n      - name: Create deployment package\n        run: |\n          cd package\n          zip -r ../lambda.zip .\n          cd ..\n      \n      - name: Upload artifact\n        uses: actions/upload-artifact@v4\n        with:\n          name: lambda-package\n          path: lambda.zip\n          retention-days: 7\n\n  terraform-validate:\n    name: Terraform Validate\n    runs-on: ubuntu-latest\n    needs: package\n    steps:\n      - uses: actions/checkout@v4\n      \n      - name: Download Lambda package\n        uses: actions/download-artifact@v4\n        with:\n          name: lambda-package\n      \n      - name: Setup Terraform\n        uses: hashicorp/setup-terraform@v3\n        with:\n          terraform_version: '1.7.0'\n      \n      - name: Terraform Format Check\n        working-directory: infra/terraform\n        run: terraform fmt -check -recursive\n      \n      - name: Terraform Init\n        working-directory: infra/terraform\n        run: |\n          terraform init -backend=false\n      \n      - name: Terraform Validate\n        working-directory: infra/terraform\n        run: terraform validate\n\n  terraform-plan:\n    name: Terraform Plan\n    runs-on: ubuntu-latest\n    needs: terraform-validate\n    if: github.event_name == 'pull_request'\n    steps:\n      - uses: actions/checkout@v4\n      \n      - name: Download Lambda package\n        uses: actions/download-artifact@v4\n        with:\n          name: lambda-package\n      \n      - name: Configure AWS Credentials\n        uses: aws-actions/configure-aws-credentials@v4\n        with:\n          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}\n          aws-region: ${{ env.AWS_REGION }}\n      \n      - name: Setup Terraform\n        uses: hashicorp/setup-terraform@v3\n        with:\n          terraform_version: '1.7.0'\n      \n      - name: Terraform Init\n        working-directory: infra/terraform\n        run: |\n          terraform init \\\n            -backend-config=\"bucket=${{ secrets.TF_STATE_BUCKET }}\" \\\n            -backend-config=\"key=staging/terraform.tfstate\" \\\n            -backend-config=\"region=${{ env.AWS_REGION }}\" \\\n            -backend-config=\"dynamodb_table=${{ secrets.TF_LOCK_TABLE }}\"\n      \n      - name: Terraform Plan\n        working-directory: infra/terraform\n        run: |\n          terraform plan \\\n            -var=\"project=${{ env.PROJECT_NAME }}\" \\\n            -var=\"env=staging\" \\\n            -var=\"region=${{ env.AWS_REGION }}\" \\\n            -out=tfplan\n      \n      - name: Comment PR with Plan\n        uses: actions/github-script@v7\n        if: github.event_name == 'pull_request'\n        with:\n          script: |\n            const output = `#### Terraform Plan ðŸ“‹\n            \n            <details><summary>Show Plan</summary>\n            \n            \\`\\`\\`\n            Plan generated successfully. Review in workflow logs.\n            \\`\\`\\`\n            \n            </details>\n            \n            *Pusher: @${{ github.actor }}, Action: \\`${{ github.event_name }}\\`*`;\n            \n            github.rest.issues.createComment({\n              issue_number: context.issue.number,\n              owner: context.repo.owner,\n              repo: context.repo.repo,\n              body: output\n            })\n\n  terraform-apply:\n    name: Terraform Apply to Staging\n    runs-on: ubuntu-latest\n    needs: terraform-validate\n    if: github.event_name == 'push' && github.ref == 'refs/heads/main'\n    environment:\n      name: staging\n      url: ${{ steps.apply.outputs.api_endpoint }}\n    steps:\n      - uses: actions/checkout@v4\n      \n      - name: Download Lambda package\n        uses: actions/download-artifact@v4\n        with:\n          name: lambda-package\n      \n      - name: Configure AWS Credentials\n        uses: aws-actions/configure-aws-credentials@v4\n        with:\n          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}\n          aws-region: ${{ env.AWS_REGION }}\n      \n      - name: Setup Terraform\n        uses: hashicorp/setup-terraform@v3\n        with:\n          terraform_version: '1.7.0'\n          terraform_wrapper: false\n      \n      - name: Terraform Init\n        working-directory: infra/terraform\n        run: |\n          terraform init \\\n            -backend-config=\"bucket=${{ secrets.TF_STATE_BUCKET }}\" \\\n            -backend-config=\"key=staging/terraform.tfstate\" \\\n            -backend-config=\"region=${{ env.AWS_REGION }}\" \\\n            -backend-config=\"dynamodb_table=${{ secrets.TF_LOCK_TABLE }}\"\n      \n      - name: Terraform Apply\n        id: apply\n        working-directory: infra/terraform\n        run: |\n          terraform apply -auto-approve \\\n            -var=\"project=${{ env.PROJECT_NAME }}\" \\\n            -var=\"env=staging\" \\\n            -var=\"region=${{ env.AWS_REGION }}\"\n          \n          echo \"api_endpoint=$(terraform output -raw api_endpoint)\" >> $GITHUB_OUTPUT\n      \n      - name: Deployment Summary\n        run: |\n          echo \"### Deployment Successful! ðŸš€\" >> $GITHUB_STEP_SUMMARY\n          echo \"\" >> $GITHUB_STEP_SUMMARY\n          echo \"**Environment:** staging\" >> $GITHUB_STEP_SUMMARY\n          echo \"**API Endpoint:** ${{ steps.apply.outputs.api_endpoint }}\" >> $GITHUB_STEP_SUMMARY\n          echo \"**Region:** ${{ env.AWS_REGION }}\" >> $GITHUB_STEP_SUMMARY\n"
      }
    ]
  },
  "ops": {
    "env_vars": {
      "create_order": {
        "ORDERS_TABLE": "DynamoDB table name for orders (e.g., serverless-app-staging-orders)",
        "EVENT_BUS_NAME": "EventBridge custom bus name for publishing events"
      },
      "get_order": {
        "ORDERS_TABLE": "DynamoDB table name for orders"
      },
      "reserve_inventory": {
        "INVENTORY_TABLE": "DynamoDB table name for inventory and idempotency markers",
        "EVENT_BUS_NAME": "EventBridge custom bus name for publishing events"
      },
      "receipts_worker": {
        "EVENT_BUS_NAME": "EventBridge custom bus name (informational)"
      },
      "csv_ingestor": {
        "EVENT_BUS_NAME": "EventBridge custom bus name for publishing customer upserted events"
      },
      "health": {
        "BUILD_SHA": "Git commit SHA or build identifier for health check response"
      }
    },
    "iam_policies": [
      {
        "name": "create-order-ddb-access",
        "policy_json": "{\"Version\":\"2012-10-17\",\"Statement\":[{\"Effect\":\"Allow\",\"Action\":[\"dynamodb:PutItem\"],\"Resource\":\"arn:aws:dynamodb:REGION:ACCOUNT:table/PROJECT-ENV-orders\"}]}"
      },
      {
        "name": "create-order-eventbridge-access",
        "policy_json": "{\"Version\":\"2012-10-17\",\"Statement\":[{\"Effect\":\"Allow\",\"Action\":[\"events:PutEvents\"],\"Resource\":\"arn:aws:events:REGION:ACCOUNT:event-bus/PROJECT-ENV-events\"}]}"
      },
      {
        "name": "get-order-ddb-access",
        "policy_json": "{\"Version\":\"2012-10-17\",\"Statement\":[{\"Effect\":\"Allow\",\"Action\":[\"dynamodb:GetItem\"],\"Resource\":\"arn:aws:dynamodb:REGION:ACCOUNT:table/PROJECT-ENV-orders\"}]}"
      },
      {
        "name": "reserve-inventory-ddb-access",
        "policy_json": "{\"Version\":\"2012-10-17\",\"Statement\":[{\"Effect\":\"Allow\",\"Action\":[\"dynamodb:PutItem\",\"dynamodb:UpdateItem\"],\"Resource\":\"arn:aws:dynamodb:REGION:ACCOUNT:table/PROJECT-ENV-inventory\"}]}"
      },
      {
        "name": "reserve-inventory-eventbridge-access",
        "policy_json": "{\"Version\":\"2012-10-17\",\"Statement\":[{\"Effect\":\"Allow\",\"Action\":[\"events:PutEvents\"],\"Resource\":\"arn:aws:events:REGION:ACCOUNT:event-bus/PROJECT-ENV-events\"}]}"
      },
      {
        "name": "csv-ingestor-s3-access",
        "policy_json": "{\"Version\":\"2012-10-17\",\"Statement\":[{\"Effect\":\"Allow\",\"Action\":[\"s3:GetObject\"],\"Resource\":\"arn:aws:s3:::PROJECT-ENV-crm-ingestion/*\"}]}"
      },
      {
        "name": "csv-ingestor-eventbridge-access",
        "policy_json": "{\"Version\":\"2012-10-17\",\"Statement\":[{\"Effect\":\"Allow\",\"Action\":[\"events:PutEvents\"],\"Resource\":\"arn:aws:events:REGION:ACCOUNT:event-bus/PROJECT-ENV-events\"}]}"
      }
    ],
    "alarms": [
      {
        "name": "CreateOrderErrors",
        "description": "Alarm when create_order Lambda function errors exceed 5 in 5 minutes"
      },
      {
        "name": "CreateOrderThrottles",
        "description": "Alarm when create_order Lambda function throttles exceed 3 in 5 minutes"
      },
      {
        "name": "ReserveInventoryErrors",
        "description": "Alarm when reserve_inventory Lambda function errors exceed 5 in 