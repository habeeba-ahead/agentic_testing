```json
{
  "bundle_manifest": [
    {
      "path": "infra/terraform/backend.tf",
      "purpose": "S3 backend configuration for Terraform state with DynamoDB locking",
      "note": "Configured per environment via tfvars"
    },
    {
      "path": "infra/terraform/variables.tf",
      "purpose": "Root variables for project, env, region, and tags"
    },
    {
      "path": "infra/terraform/main.tf",
      "purpose": "Orchestrates all modules: API, Lambda functions, DynamoDB tables, EventBridge, S3, IAM policies"
    },
    {
      "path": "infra/terraform/outputs.tf",
      "purpose": "Exports API endpoint, table names, bus name, bucket name for ops/CI"
    },
    {
      "path": "infra/terraform/iam.tf",
      "purpose": "Least-privilege IAM roles and policies for each Lambda function"
    },
    {
      "path": "infra/terraform/alarms.tf",
      "purpose": "CloudWatch alarms for Lambda errors, throttles, and API 5xx responses"
    },
    {
      "path": "src/orders/handlers.py",
      "purpose": "Orders service: create_order and get_order handlers"
    },
    {
      "path": "src/receipts/worker.py",
      "purpose": "Receipts worker: EventBridge consumer for ReceiptGenerated events"
    },
    {
      "path": "src/ingestor/process_csv.py",
      "purpose": "CRM ingestor: S3 trigger to parse CSV and emit CustomerUpserted events"
    },
    {
      "path": "src/inventory/handlers.py",
      "purpose": "Inventory service: reserve handler with idempotency and concurrency control"
    },
    {
      "path": "src/ops/health.py",
      "purpose": "Health check endpoint for API monitoring"
    },
    {
      "path": ".github/workflows/ci.yml",
      "purpose": "CI/CD pipeline: lint, test, package, Terraform plan/apply with OIDC"
    },
    {
      "path": "tests/test_orders.py",
      "purpose": "Unit tests for orders handlers"
    },
    {
      "path": "tests/test_inventory.py",
      "purpose": "Unit tests for inventory reserve handler"
    },
    {
      "path": "tests/test_ingestor.py",
      "purpose": "Unit tests for CRM CSV ingestor"
    },
    {
      "path": "requirements.txt",
      "purpose": "Python dependencies for Lambda functions"
    },
    {
      "path": "requirements-dev.txt",
      "purpose": "Development dependencies for testing and linting"
    },
    {
      "path": "README.md",
      "purpose": "Project overview, setup instructions, deployment guide"
    },
    {
      "path": "CHANGELOG.md",
      "purpose": "Version history and release notes"
    }
  ],
  "src": {
    "files": [
      {
        "path": "src/orders/handlers.py",
        "content": "# src/orders/handlers.py\nimport os, json, time, uuid, boto3\n\ndynamodb = boto3.resource(\"dynamodb\")\nevents = boto3.client(\"events\")\n\nTABLE_NAME = os.getenv(\"ORDERS_TABLE\", \"\")\nBUS_NAME = os.getenv(\"EVENT_BUS_NAME\", \"\")\n\ndef create_order(event, context):\n    \"\"\"Create a new order and emit ReceiptGenerated event.\"\"\"\n    body = json.loads(event.get(\"body\") or \"{}\")\n    if \"total\" not in body:\n        return {\"statusCode\": 400, \"body\": json.dumps({\"error\": \"total required\"})}\n    \n    order_id = str(uuid.uuid4())\n    item = {\n        \"order_id\": order_id,\n        \"status\": \"CREATED\",\n        \"total\": float(body.get(\"total\", 0.0)),\n        \"created_at\": time.strftime(\"%Y-%m-%dT%H:%M:%SZ\"),\n    }\n    \n    dynamodb.Table(TABLE_NAME).put_item(Item=item)\n    \n    if BUS_NAME:\n        events.put_events(Entries=[{\n            \"Source\": \"app.orders\",\n            \"DetailType\": \"ReceiptGenerated\",\n            \"Detail\": json.dumps({\"order_id\": order_id, \"total\": item[\"total\"]}),\n            \"EventBusName\": BUS_NAME\n        }])\n    \n    return {\"statusCode\": 201, \"body\": json.dumps({\"order_id\": order_id})}\n\ndef get_order(event, context):\n    \"\"\"Retrieve an order by ID.\"\"\"\n    order_id = (event.get(\"pathParameters\") or {}).get(\"order_id\")\n    if not order_id:\n        return {\"statusCode\": 400, \"body\": json.dumps({\"error\": \"order_id required\"})}\n    \n    res = dynamodb.Table(TABLE_NAME).get_item(Key={\"order_id\": order_id})\n    if \"Item\" not in res:\n        return {\"statusCode\": 404, \"body\": json.dumps({\"error\": \"Not found\"})}\n    \n    return {\"statusCode\": 200, \"body\": json.dumps(res[\"Item\"])}\n"
      },
      {
        "path": "src/receipts/worker.py",
        "content": "# src/receipts/worker.py\nimport json, os, logging\n\nlogger = logging.getLogger()\nlogger.setLevel(logging.INFO)\n\ndef handler(event, context):\n    \"\"\"Process ReceiptGenerated events from EventBridge.\"\"\"\n    detail = event.get(\"detail\", {})\n    order_id = detail.get(\"order_id\")\n    total = detail.get(\"total\")\n    \n    logger.info(json.dumps({\n        \"message\": \"Receipt processing triggered\",\n        \"order_id\": order_id,\n        \"total\": total\n    }))\n    \n    # Placeholder for actual receipt generation logic\n    return {\"ok\": True, \"order_id\": order_id}\n"
      },
      {
        "path": "src/ingestor/process_csv.py",
        "content": "# src/ingestor/process_csv.py\nimport csv, os, json, boto3, logging\n\nlogger = logging.getLogger()\nlogger.setLevel(logging.INFO)\n\ns3 = boto3.client(\"s3\")\nevents = boto3.client(\"events\")\n\nBUS_NAME = os.getenv(\"EVENT_BUS_NAME\", \"\")\n\ndef handler(event, context):\n    \"\"\"Process CSV files from S3 and emit CustomerUpserted events.\"\"\"\n    rec = (event.get(\"Records\") or [])[0][\"s3\"]\n    bucket = rec[\"bucket\"][\"name\"]\n    key = rec[\"object\"][\"key\"]\n    \n    logger.info(json.dumps({\"message\": \"Processing CSV\", \"bucket\": bucket, \"key\": key}))\n    \n    obj = s3.get_object(Bucket=bucket, Key=key)\n    body = obj[\"Body\"].read().decode(\"utf-8\")\n    \n    count = 0\n    for row in csv.DictReader(body.splitlines()):\n        if not row.get(\"customer_id\") or not row.get(\"email\"):\n            continue\n        \n        count += 1\n        if BUS_NAME:\n            events.put_events(Entries=[{\n                \"Source\": \"app.crm\",\n                \"DetailType\": \"CustomerUpserted\",\n                \"EventBusName\": BUS_NAME,\n                \"Detail\": json.dumps({\n                    \"customer_id\": row[\"customer_id\"],\n                    \"email\": row[\"email\"],\n                    \"segment\": row.get(\"segment\", \"\")\n                })\n            }])\n    \n    logger.info(json.dumps({\"message\": \"CSV processed\", \"records_emitted\": count}))\n    return {\"ok\": True, \"emitted\": count}\n"
      },
      {
        "path": "src/inventory/handlers.py",
        "content": "# src/inventory/handlers.py\nimport os, json, time, boto3, logging\n\nlogger = logging.getLogger()\nlogger.setLevel(logging.INFO)\n\nddb = boto3.client(\"dynamodb\")\nevents = boto3.client(\"events\")\n\nTABLE = os.getenv(\"INVENTORY_TABLE\", \"\")\nBUS = os.getenv(\"EVENT_BUS_NAME\", \"\")\n\ndef reserve(event, context):\n    \"\"\"Reserve inventory with idempotency and concurrency control.\"\"\"\n    body = json.loads(event.get(\"body\") or \"{}\")\n    sku = body.get(\"sku\")\n    qty = int(body.get(\"qty\", 0))\n    req = body.get(\"request_id\")\n    \n    if not sku or qty <= 0 or not req:\n        return {\n            \"statusCode\": 400,\n            \"body\": json.dumps({\"error\": \"sku, qty>0, request_id required\"})\n        }\n    \n    # Idempotency marker: put if not exists with 24h TTL\n    try:\n        ddb.put_item(\n            TableName=TABLE,\n            Item={\n                \"sku\": {\"S\": f\"idem#{req}\"},\n                \"ttl\": {\"N\": str(int(time.time()) + 86400)}\n            },\n            ConditionExpression=\"attribute_not_exists(sku)\"\n        )\n    except ddb.exceptions.ConditionalCheckFailedException:\n        logger.info(json.dumps({\"message\": \"Duplicate request\", \"request_id\": req}))\n        return {\n            \"statusCode\": 200,\n            \"body\": json.dumps({\"status\": \"duplicate\", \"request_id\": req})\n        }\n    \n    # Decrement stock with concurrency guard\n    try:\n        resp = ddb.update_item(\n            TableName=TABLE,\n            Key={\"sku\": {\"S\": sku}},\n            UpdateExpression=\"SET qty = qty - :q\",\n            ConditionExpression=\"qty >= :q\",\n            ExpressionAttributeValues={\n                \":q\": {\"N\": str(qty)}\n            },\n            ReturnValues=\"ALL_NEW\"\n        )\n    except ddb.exceptions.ConditionalCheckFailedException:\n        logger.warning(json.dumps({\"message\": \"Insufficient inventory\", \"sku\": sku, \"qty\": qty}))\n        return {\n            \"statusCode\": 409,\n            \"body\": json.dumps({\"error\": \"insufficient\"})\n        }\n    \n    remaining = int(resp[\"Attributes\"][\"qty\"][\"N\"])\n    \n    if BUS:\n        events.put_events(Entries=[{\n            \"Source\": \"app.inventory\",\n            \"DetailType\": \"InventoryReserved\",\n            \"EventBusName\": BUS,\n            \"Detail\": json.dumps({\n                \"sku\": sku,\n                \"qty\": qty,\n                \"remaining\": remaining,\n                \"request_id\": req\n            })\n        }])\n    \n    logger.info(json.dumps({\"message\": \"Inventory reserved\", \"sku\": sku, \"qty\": qty, \"remaining\": remaining}))\n    return {\"statusCode\": 200, \"body\": json.dumps({\"remaining\": remaining})}\n"
      },
      {
        "path": "src/ops/health.py",
        "content": "# src/ops/health.py\nimport json, os, time\n\ndef handler(event, context):\n    \"\"\"Health check endpoint.\"\"\"\n    return {\n        \"statusCode\": 200,\n        \"body\": json.dumps({\n            \"status\": \"ok\",\n            \"sha\": os.getenv(\"BUILD_SHA\", \"dev\"),\n            \"time\": time.strftime(\"%Y-%m-%dT%H:%M:%SZ\")\n        })\n    }\n"
      }
    ]
  },
  "infra": {
    "terraform": {
      "files": [
        {
          "path": "infra/terraform/backend.tf",
          "content": "# infra/terraform/backend.tf\nterraform {\n  backend \"s3\" {\n    # Configure via CLI or tfvars:\n    # bucket         = \"<project>-<env>-tfstate\"\n    # key            = \"terraform.tfstate\"\n    # region         = \"us-east-1\"\n    # dynamodb_table = \"<project>-<env>-tflock\"\n    # encrypt        = true\n  }\n}\n"
        },
        {
          "path": "infra/terraform/variables.tf",
          "content": "# infra/terraform/variables.tf\nvariable \"project\" {\n  type        = string\n  description = \"Project name for resource naming\"\n}\n\nvariable \"env\" {\n  type        = string\n  description = \"Environment (staging, prod)\"\n}\n\nvariable \"region\" {\n  type        = string\n  description = \"AWS region\"\n  default     = \"us-east-1\"\n}\n\nvariable \"tags\" {\n  type        = map(string)\n  description = \"Common tags for all resources\"\n  default     = {}\n}\n"
        },
        {
          "path": "infra/terraform/main.tf",
          "content": "# infra/terraform/main.tf\nterraform {\n  required_version = \">= 1.7.0\"\n  required_providers {\n    aws = {\n      source  = \"hashicorp/aws\"\n      version = \">= 5.0\"\n    }\n  }\n}\n\nprovider \"aws\" {\n  region = var.region\n}\n\nlocals {\n  name_prefix = \"${var.project}-${var.env}\"\n  common_tags = merge(var.tags, {\n    Project     = var.project\n    Environment = var.env\n    ManagedBy   = \"Terraform\"\n  })\n}\n\n# ========== DynamoDB Tables ==========\nresource \"aws_dynamodb_table\" \"orders\" {\n  name         = \"${local.name_prefix}-orders\"\n  billing_mode = \"PAY_PER_REQUEST\"\n  hash_key     = \"order_id\"\n\n  attribute {\n    name = \"order_id\"\n    type = \"S\"\n  }\n\n  tags = local.common_tags\n}\n\nresource \"aws_dynamodb_table\" \"inventory\" {\n  name         = \"${local.name_prefix}-inventory\"\n  billing_mode = \"PAY_PER_REQUEST\"\n  hash_key     = \"sku\"\n\n  attribute {\n    name = \"sku\"\n    type = \"S\"\n  }\n\n  ttl {\n    attribute_name = \"ttl\"\n    enabled        = true\n  }\n\n  tags = local.common_tags\n}\n\n# ========== EventBridge Bus ==========\nresource \"aws_cloudwatch_event_bus\" \"main\" {\n  name = \"${local.name_prefix}-bus\"\n  tags = local.common_tags\n}\n\n# ========== S3 Bucket for CRM Ingestion ==========\nresource \"aws_s3_bucket\" \"crm_ingestion\" {\n  bucket        = \"${local.name_prefix}-crm-ingestion\"\n  force_destroy = var.env != \"prod\"\n  tags          = local.common_tags\n}\n\nresource \"aws_s3_bucket_public_access_block\" \"crm_ingestion\" {\n  bucket                  = aws_s3_bucket.crm_ingestion.id\n  block_public_acls       = true\n  block_public_policy     = true\n  ignore_public_acls      = true\n  restrict_public_buckets = true\n}\n\n# ========== HTTP API Gateway ==========\nresource \"aws_apigatewayv2_api\" \"main\" {\n  name          = \"${local.name_prefix}-api\"\n  protocol_type = \"HTTP\"\n\n  cors_configuration {\n    allow_headers = [\"*\"]\n    allow_methods = [\"*\"]\n    allow_origins = [\"*\"]\n  }\n\n  tags = local.common_tags\n}\n\nresource \"aws_apigatewayv2_stage\" \"main\" {\n  api_id      = aws_apigatewayv2_api.main.id\n  name        = var.env\n  auto_deploy = true\n\n  tags = local.common_tags\n}\n\n# ========== Lambda Functions ==========\n\n# Orders - Create\nresource \"aws_lambda_function\" \"orders_create\" {\n  function_name = \"${local.name_prefix}-orders-create\"\n  role          = aws_iam_role.orders_lambda.arn\n  runtime       = \"python3.11\"\n  handler       = \"orders.handlers.create_order\"\n  timeout       = 15\n  memory_size   = 512\n  filename      = \"${path.module}/../../lambda_package.zip\"\n  source_code_hash = fileexists(\"${path.module}/../../lambda_package.zip\") ? filebase64sha256(\"${path.module}/../../lambda_package.zip\") : null\n\n  environment {\n    variables = {\n      ORDERS_TABLE    = aws_dynamodb_table.orders.name\n      EVENT_BUS_NAME  = aws_cloudwatch_event_bus.main.name\n    }\n  }\n\n  tags = local.common_tags\n}\n\n# Orders - Get\nresource \"aws_lambda_function\" \"orders_get\" {\n  function_name = \"${local.name_prefix}-orders-get\"\n  role          = aws_iam_role.orders_lambda.arn\n  runtime       = \"python3.11\"\n  handler       = \"orders.handlers.get_order\"\n  timeout       = 15\n  memory_size   = 512\n  filename      = \"${path.module}/../../lambda_package.zip\"\n  source_code_hash = fileexists(\"${path.module}/../../lambda_package.zip\") ? filebase64sha256(\"${path.module}/../../lambda_package.zip\") : null\n\n  environment {\n    variables = {\n      ORDERS_TABLE = aws_dynamodb_table.orders.name\n    }\n  }\n\n  tags = local.common_tags\n}\n\n# Inventory - Reserve\nresource \"aws_lambda_function\" \"inventory_reserve\" {\n  function_name = \"${local.name_prefix}-inventory-reserve\"\n  role          = aws_iam_role.inventory_lambda.arn\n  runtime       = \"python3.11\"\n  handler       = \"inventory.handlers.reserve\"\n  timeout       = 15\n  memory_size   = 512\n  filename      = \"${path.module}/../../lambda_package.zip\"\n  source_code_hash = fileexists(\"${path.module}/../../lambda_package.zip\") ? filebase64sha256(\"${path.module}/../../lambda_package.zip\") : null\n\n  environment {\n    variables = {\n      INVENTORY_TABLE = aws_dynamodb_table.inventory.name\n      EVENT_BUS_NAME  = aws_cloudwatch_event_bus.main.name\n    }\n  }\n\n  tags = local.common_tags\n}\n\n# Receipts Worker\nresource \"aws_lambda_function\" \"receipts_worker\" {\n  function_name = \"${local.name_prefix}-receipts-worker\"\n  role          = aws_iam_role.receipts_lambda.arn\n  runtime       = \"python3.11\"\n  handler       = \"receipts.worker.handler\"\n  timeout       = 15\n  memory_size   = 512\n  filename      = \"${path.module}/../../lambda_package.zip\"\n  source_code_hash = fileexists(\"${path.module}/../../lambda_package.zip\") ? filebase64sha256(\"${path.module}/../../lambda_package.zip\") : null\n\n  tags = local.common_tags\n}\n\n# CRM Ingestor\nresource \"aws_lambda_function\" \"crm_ingestor\" {\n  function_name = \"${local.name_prefix}-crm-ingestor\"\n  role          = aws_iam_role.ingestor_lambda.arn\n  runtime       = \"python3.11\"\n  handler       = \"ingestor.process_csv.handler\"\n  timeout       = 60\n  memory_size   = 512\n  filename      = \"${path.module}/../../lambda_package.zip\"\n  source_code_hash = fileexists(\"${path.module}/../../lambda_package.zip\") ? filebase64sha256(\"${path.module}/../../lambda_package.zip\") : null\n\n  environment {\n    variables = {\n      EVENT_BUS_NAME = aws_cloudwatch_event_bus.main.name\n    }\n  }\n\n  tags = local.common_tags\n}\n\n# Health Check\nresource \"aws_lambda_function\" \"health\" {\n  function_name = \"${local.name_prefix}-health\"\n  role          = aws_iam_role.health_lambda.arn\n  runtime       = \"python3.11\"\n  handler       = \"ops.health.handler\"\n  timeout       = 5\n  memory_size   = 256\n  filename      = \"${path.module}/../../lambda_package.zip\"\n  source_code_hash = fileexists(\"${path.module}/../../lambda_package.zip\") ? filebase64sha256(\"${path.module}/../../lambda_package.zip\") : null\n\n  tags = local.common_tags\n}\n\n# ========== API Gateway Integrations ==========\n\n# POST /orders\nresource \"aws_apigatewayv2_integration\" \"orders_create\" {\n  api_id                 = aws_apigatewayv2_api.main.id\n  integration_type       = \"AWS_PROXY\"\n  integration_method     = \"POST\"\n  integration_uri        = aws_lambda_function.orders_create.arn\n  payload_format_version = \"2.0\"\n}\n\nresource \"aws_apigatewayv2_route\" \"orders_create\" {\n  api_id    = aws_apigatewayv2_api.main.id\n  route_key = \"POST /orders\"\n  target    = \"integrations/${aws_apigatewayv2_integration.orders_create.id}\"\n}\n\nresource \"aws_lambda_permission\" \"orders_create_api\" {\n  statement_id  = \"AllowAPIInvoke\"\n  action        = \"lambda:InvokeFunction\"\n  function_name = aws_lambda_function.orders_create.function_name\n  principal     = \"apigateway.amazonaws.com\"\n  source_arn    = \"${aws_apigatewayv2_api.main.execution_arn}/*/*/orders\"\n}\n\n# GET /orders/{order_id}\nresource \"aws_apigatewayv2_integration\" \"orders_get\" {\n  api_id                 = aws_apigatewayv2_api.main.id\n  integration_type       = \"AWS_PROXY\"\n  integration_method     = \"POST\"\n  integration_uri        = aws_lambda_function.orders_get.arn\n  payload_format_version = \"2.0\"\n}\n\nresource \"aws_apigatewayv2_route\" \"orders_get\" {\n  api_id    = aws_apigatewayv2_api.main.id\n  route_key = \"GET /orders/{order_id}\"\n  target    = \"integrations/${aws_apigatewayv2_integration.orders_get.id}\"\n}\n\nresource \"aws_lambda_permission\" \"orders_get_api\" {\n  statement_id  = \"AllowAPIInvoke\"\n  action        = \"lambda:InvokeFunction\"\n  function_name = aws_lambda_function.orders_get.function_name\n  principal     = \"apigateway.amazonaws.com\"\n  source_arn    = \"${aws_apigatewayv2_api.main.execution_arn}/*/*/orders/*\"\n}\n\n# POST /inventory/reserve\nresource \"aws_apigatewayv2_integration\" \"inventory_reserve\" {\n  api_id                 = aws_apigatewayv2_api.main.id\n  integration_type       = \"AWS_PROXY\"\n  integration_method     = \"POST\"\n  integration_uri        = aws_lambda_function.inventory_reserve.arn\n  payload_format_version = \"2.0\"\n}\n\nresource \"aws_apigatewayv2_route\" \"inventory_reserve\" {\n  api_id    = aws_apigatewayv2_api.main.id\n  route_key = \"POST /inventory/reserve\"\n  target    = \"integrations/${aws_apigatewayv2_integration.inventory_reserve.id}\"\n}\n\nresource \"aws_lambda_permission\" \"inventory_reserve_api\" {\n  statement_id  = \"AllowAPIInvoke\"\n  action        = \"lambda:InvokeFunction\"\n  function_name = aws_lambda_function.inventory_reserve.function_name\n  principal     = \"apigateway.amazonaws.com\"\n  source_arn    = \"${aws_apigatewayv2_api.main.execution_arn}/*/*/inventory/reserve\"\n}\n\n# GET /health\nresource \"aws_apigatewayv2_integration\" \"health\" {\n  api_id                 = aws_apigatewayv2_api.main.id\n  integration_type       = \"AWS_PROXY\"\n  integration_method     = \"POST\"\n  integration_uri        = aws_lambda_function.health.arn\n  payload_format_version = \"2.0\"\n}\n\nresource \"aws_apigatewayv2_route\" \"health\" {\n  api_id    = aws_apigatewayv2_api.main.id\n  route_key = \"GET /health\"\n  target    = \"integrations/${aws_apigatewayv2_integration.health.id}\"\n}\n\nresource \"aws_lambda_permission\" \"health_api\" {\n  statement_id  = \"AllowAPIInvoke\"\n  action        = \"lambda:InvokeFunction\"\n  function_name = aws_lambda_function.health.function_name\n  principal     = \"apigateway.amazonaws.com\"\n  source_arn    = \"${aws_apigatewayv2_api.main.execution_arn}/*/*/health\"\n}\n\n# ========== EventBridge Rules ==========\n\n# ReceiptGenerated → Receipts Worker\nresource \"aws_cloudwatch_event_rule\" \"receipt_generated\" {\n  name           = \"${local.name_prefix}-receipt-generated\"\n  event_bus_name = aws_cloudwatch_event_bus.main.name\n  event_pattern = jsonencode({\n    source      = [\"app.orders\"]\n    detail-type = [\"ReceiptGenerated\"]\n  })\n  tags = local.common_tags\n}\n\nresource \"aws_cloudwatch_event_target\" \"receipt_worker\" {\n  rule           = aws_cloudwatch_event_rule.receipt_generated.name\n  event_bus_name = aws_cloudwatch_event_bus.main.name\n  arn            = aws_lambda_function.receipts_worker.arn\n}\n\nresource \"aws_lambda_permission\" \"receipts_eventbridge\" {\n  statement_id  = \"AllowEventBridgeInvoke\"\n  action        = \"lambda:InvokeFunction\"\n  function_name = aws_lambda_function.receipts_worker.function_name\n  principal     = \"events.amazonaws.com\"\n  source_arn    = aws_cloudwatch_event_rule.receipt_generated.arn\n}\n\n# ========== S3 Notification ==========\n\nresource \"aws_lambda_permission\" \"crm_s3\" {\n  statement_id  = \"AllowS3Invoke\"\n  action        = \"lambda:InvokeFunction\"\n  function_name = aws_lambda_function.crm_ingestor.function_name\n  principal     = \"s3.amazonaws.com\"\n  source_arn    = aws_s3_bucket.crm_ingestion.arn\n}\n\nresource \"aws_s3_bucket_notification\" \"crm_ingestion\" {\n  bucket = aws_s3_bucket.crm_ingestion.id\n\n  lambda_function {\n    lambda_function_arn = aws_lambda_function.crm_ingestor.arn\n    events              = [\"s3:ObjectCreated:*\"]\n    filter_suffix       = \".csv\"\n  }\n\n  depends_on = [aws_lambda_permission.crm_s3]\n}\n"
        },
        {
          "path": "infra/terraform/iam.tf",
          "content": "# infra/terraform/iam.tf\n\n# ========== Orders Lambda Role ==========\nresource \"aws_iam_role\" \"orders_lambda\" {\n  name = \"${local.name_prefix}-orders-lambda\"\n  assume_role_policy = jsonencode({\n    Version = \"2012-10-17\"\n    Statement = [{\n      Effect = \"Allow\"\n      Principal = { Service = \"lambda.amazonaws.com\" }\n      Action = \"sts:AssumeRole\"\n    }]\n  })\n  tags = local.common_tags\n}\n\nresource \"aws_iam_role_policy_attachment\" \"orders_lambda_logs\" {\n  role       = aws_iam_role.orders_lambda.name\n  policy_arn = \"arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole\"\n}\n\nresource \"aws_iam_role_policy\" \"orders_lambda_ddb\" {\n  name = \"ddb-access\"\n  role = aws_iam_role.orders_lambda.id\n  policy = jsonencode({\n    Version = \"2012-10-17\"\n    Statement = [\n      {\n        Effect = \"Allow\"\n        Action = [\n          \"dynamodb:PutItem\",\n          \"dynamodb:GetItem\"\n        ]\n        Resource = aws_dynamodb_table.orders.arn\n      }\n    ]\n  })\n}\n\nresource \"aws_iam_role_policy\" \"orders_lambda_events\" {\n  name = \"events-access\"\n  role = aws_iam_role.orders_lambda.id\n  policy = jsonencode({\n    Version = \"2012-10-17\"\n    Statement = [\n      {\n        Effect = \"Allow\"\n        Action = \"events:PutEvents\"\n        Resource = aws_cloudwatch_event_bus.main.arn\n      }\n    ]\n  })\n}\n\n# ========== Inventory Lambda Role ==========\nresource \"aws_iam_role\" \"inventory_lambda\" {\n  name = \"${local.name_prefix}-inventory-lambda\"\n  assume_role_policy = jsonencode({\n    Version = \"2012-10-17\"\n    Statement = [{\n      Effect = \"Allow\"\n      Principal = { Service = \"lambda.amazonaws.com\" }\n      Action = \"sts:AssumeRole\"\n    }]\n  })\n  tags = local.common_tags\n}\n\nresource \"aws_iam_role_policy_attachment\" \"inventory_lambda_logs\" {\n  role       = aws_iam_role.inventory_lambda.name\n  policy_arn = \"arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole\"\n}\n\nresource \"aws_iam_role_policy\" \"inventory_lambda_ddb\" {\n  name = \"ddb-access\"\n  role = aws_iam_role.inventory_lambda.id\n  policy = jsonencode({\n    Version = \"2012-10-17\"\n    Statement = [\n      {\n        Effect = \"Allow\"\n        Action = [\n          \"dynamodb:PutItem\",\n          \"dynamodb:UpdateItem\",\n          \"dynamodb:GetItem\"\n        ]\n        Resource = aws_dynamodb_table.inventory.arn\n      }\n    ]\n  })\n}\n\nresource \"aws_iam_role_policy\" \"inventory_lambda_events\" {\n  name = \"events-access\"\n  role = aws_iam_role.inventory_lambda.id\n  policy = jsonencode({\n    Version = \"2012-10-17\"\n    Statement = [\n      {\n        Effect = \"Allow\"\n        Action = \"events:PutEvents\"\n        Resource = aws_cloudwatch_event_bus.main.arn\n      }\n    ]\n  })\n}\n\n# ========== Receipts Lambda Role ==========\nresource \"aws_iam_role\" \"receipts_lambda\" {\n  name = \"${local.name_prefix}-receipts-lambda\"\n  assume_role_policy = jsonencode({\n    Version = \"2012-10-17\"\n    Statement = [{\n      Effect = \"Allow\"\n      Principal = { Service = \"lambda.amazonaws.com\" }\n      Action = \"sts:AssumeRole\"\n    }]\n  })\n  tags = local.common_tags\n}\n\nresource \"aws_iam_role_policy_attachment\" \"receipts_lambda_logs\" {\n  role       = aws_iam_role.receipts_lambda.name\n  policy_arn = \"arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole\"\n}\n\n# ========== CRM Ingestor Lambda Role ==========\nresource \"aws_iam_role\" \"ingestor_lambda\" {\n  name = \"${local.name_prefix}-ingestor-lambda\"\n  assume_role_policy = jsonencode({\n    Version = \"2012-10-17\"\n    Statement = [{\n      Effect = \"Allow\"\n      Principal = { Service = \"lambda.amazonaws.com\" }\n      Action = \"sts:AssumeRole\"\n    }]\n  })\n  tags = local.common_tags\n}\n\nresource \"aws_iam_role_policy_attachment\" \"ingestor_lambda_logs\" {\n  role       = aws_iam_role.ingestor_lambda.name\n  policy_arn = \"arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole\"\n}\n\nresource \"aws_iam_role_policy\" \"ingestor_lambda_s3\" {\n  name = \"s3-access\"\n  role = aws_iam_role.ingestor_lambda.id\n  policy = jsonencode({\n    Version = \"2012-10-17\"\n    Statement = [\n      {\n        Effect = \"Allow\"\n        Action = [\n          \"s3:GetObject\"\n        ]\n        Resource = \"${aws_s3_bucket.crm_ingestion.arn}/*\"\n      }\n    ]\n  })\n}\n\nresource \"aws_iam_role_policy\" \"ingestor_lambda_events\" {\n  name = \"events-access\"\n  role = aws_iam_role.ingestor_lambda.id\n  policy = jsonencode({\n    Version = \"2012-10-17\"\n    Statement = [\n      {\n        Effect = \"Allow\"\n        Action = \"events:PutEvents\"\n        Resource = aws_cloudwatch_event_bus.main.arn\n      }\n    ]\n  })\n}\n\n# ========== Health Lambda Role ==========\nresource \"aws_iam_role\" \"health_lambda\" {\n  name = \"${local.name_prefix}-health-lambda\"\n  assume_role_policy = jsonencode({\n    Version = \"2012-10-17\"\n    Statement = [{\n      Effect = \"Allow\"\n      Principal = { Service = \"lambda.amazonaws.com\" }\n      Action = \"sts:AssumeRole\"\n    }]\n  })\n  tags = local.common_tags\n}\n\nresource \"aws_iam_role_policy_attachment\" \"health_lambda_logs\" {\n  role       = aws_iam_role.health_lambda.name\n  policy_arn = \"arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole\"\n}\n"
        },
        {
          "path": "infra/terraform/alarms.tf",
          "content": "# infra/terraform/alarms.tf\n\n# ========== Lambda Error Alarms ==========\nresource \"aws_cloudwatch_metric_alarm\" \"orders_create_errors\" {\n  alarm_name          = \"${local.name_prefix}-orders-create-errors\"\n  comparison_operator = \"GreaterThanThreshold\"\n  evaluation_periods  = 2\n  metric_name         = \"Errors\"\n  namespace           = \"AWS/Lambda\"\n  period              = 60\n  statistic           = \"Sum\"\n  threshold           = 5\n  alarm_description   = \"Orders create Lambda errors exceed threshold\"\n  dimensions = {\n    FunctionName = aws_lambda_function.orders_create.function_name\n  }\n  tags = local.common_tags\n}\n\nresource \"aws_cloudwatch_metric_alarm\" \"inventory_reserve_errors\" {\n  alarm_name          = \"${local.name_prefix}-inventory-reserve-errors\"\n  comparison_operator = \"GreaterThanThreshold\"\n  evaluation_periods  = 2\n  metric_name         = \"Errors\"\n  namespace           = \"AWS/Lambda\"\n  period              = 60\n  statistic           = \"Sum\"\n  threshold           = 5\n  alarm_description   = \"Inventory reserve Lambda errors exceed threshold\"\n  dimensions = {\n    FunctionName = aws_lambda_function.inventory_reserve.function_name\n  }\n  tags = local.common_tags\n}\n\nresource \"aws_cloudwatch_metric_alarm\" \"crm_ingestor_errors\" {\n  alarm_name          = \"${local.name_prefix}-crm-ingestor-errors\"\n  comparison_operator = \"GreaterThanThreshold\"\n  evaluation_periods  = 2\n  metric_name         = \"Errors\"\n  namespace           = \"AWS/Lambda\"\n  period              = 300\n  statistic           = \"Sum\"\n  threshold           = 3\n  alarm_description   = \"CRM ingestor Lambda errors exceed threshold\"\n  dimensions = {\n    FunctionName = aws_lambda_function.crm_ingestor.function_name\n  }\n  tags = local.common_tags\n}\n\n# ========== Lambda Throttle Alarms ==========\nresource \"aws_cloudwatch_metric_alarm\" \"orders_create_throttles\" {\n  alarm_name          = \"${local.name_prefix}-orders-create-throttles\"\n  comparison_operator = \"GreaterThanThreshold\"\n  evaluation_periods  = 1\n  metric_name         = \"Throttles\"\n  namespace           = \"AWS/Lambda\"\n  period              = 60\n  statistic           = \"Sum\"\n  threshold           = 10\n  alarm_description   = \"Orders create Lambda throttles exceed threshold\"\n  dimensions = {\n    FunctionName = aws_lambda_function.orders_create.function_name\n  }\n  tags = local.common_tags\n}\n\nresource \"aws_cloudwatch_metric_alarm\" \"inventory_reserve_throttles\" {\n  alarm_name          = \"${local.name_prefix}-inventory-reserve-throttles\"\n  comparison_operator = \"GreaterThanThreshold\"\n  evaluation_periods  = 1\n  metric_name         = \"Throttles\"\n  namespace           = \"AWS/Lambda\"\n  period              = 60\n  statistic           = \"Sum\"\n  threshold           = 10\n  alarm_description   = \"Inventory reserve Lambda throttles exceed threshold\"\n  dimensions = {\n    FunctionName = aws_lambda_function.inventory_reserve.function_name\n  }\n  tags = local.common_tags\n}\n\n# ========== API Gateway 5xx Alarm ==========\nresource \"aws_cloudwatch_metric_alarm\" \"api_5xx\" {\n  alarm_name          = \"${local.name_prefix}-api-5xx-errors\"\n  comparison_operator = \"GreaterThanThreshold\"\n  evaluation_periods  = 2\n  metric_name         = \"5XXError\"\n  namespace           = \"AWS/ApiGateway\"\n  period              = 60\n  statistic           = \"Sum\"\n  threshold           = 10\n  alarm_description   = \"API Gateway 5xx errors exceed threshold\"\n  dimensions = {\n    ApiId = aws_apigatewayv2_api.main.id\n  }\n  tags = local.common_tags\n}\n"
        },
        {
          "path": "infra/terraform/outputs.tf",
          "content": "# infra/terraform/outputs.tf\n\noutput \"api_endpoint\" {\n  description = \"HTTP API Gateway endpoint\"\n  value       = \"${aws_apigatewayv2_api.main.api_endpoint}/${var.env}\"\n}\n\noutput \"orders_table_name\" {\n  description = \"Orders DynamoDB table name\"\n  value       = aws_dynamodb_table.orders.name\n}\n\noutput \"inventory_table_name\" {\n  description = \"Inventory DynamoDB table name\"\n  value       = aws_dynamodb_table.inventory.name\n}\n\noutput \"event_bus_name\" {\n  description = \"EventBridge bus name\"\n  value       = aws_cloudwatch_event_bus.main.name\n}\n\noutput \"crm_ingestion_bucket\" {\n  description = \"S3 bucket for CRM CSV ingestion\"\n  value       = aws_s3_bucket.crm_ingestion.bucket\n}\n\noutput \"lambda_functions\" {\n  description = \"Deployed Lambda function names\"\n  value = {\n    orders_create      = aws_lambda_function.orders_create.function_name\n    orders_get         = aws_lambda_function.orders_get.function_name\n    inventory_reserve  = aws_lambda_function.inventory_reserve.function_name\n    receipts_worker    = aws_lambda_function.receipts_worker.function_name\n    crm_ingestor       = aws_lambda_function.crm_ingestor.function_name\n    health             = aws_lambda_function.health.function_name\n  }\n}\n"
        }
      ]
    }
  },
  "ci": {
    "workflows": [
      {
        "path": ".github/workflows/ci.yml",
        "content": "name: CI/CD Pipeline\n\non:\n  pull_request:\n    branches: [main]\n  push:\n    branches: [main]\n\nenv:\n  AWS_REGION: us-east-1\n  PROJECT_NAME: serverless-backend\n  PYTHON_VERSION: '3.11'\n\npermissions:\n  id-token: write\n  contents: read\n  pull-requests: write\n\njobs:\n  lint:\n    name: Lint\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      \n      - name: Set up Python\n        uses: actions/setup-python@v5\n        with:\n          python-version: ${{ env.PYTHON_VERSION }}\n      \n      - name: Install dependencies\n        run: |\n          pip install -r requirements-dev.txt\n      \n      - name: Run flake8\n        run: |\n          flake8 src/ --count --select=E9,F63,F7,F82 --show-source --statistics\n          flake8 src/ --count --exit-zero --max-complexity=10 --max-line-length=127 --statistics\n\n  test:\n    name: Test\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      \n      - name: Set up Python\n        uses: actions/setup-python@v5\n        with:\n          python-version: ${{ env.PYTHON_VERSION }}\n      \n      - name: Install dependencies\n        run: |\n          pip install -r requirements.txt\n          pip install -r requirements-dev.txt\n      \n      - name: Run tests\n        run: |\n          pytest tests/ -v --cov=src --cov-report=term-missing\n\n  package:\n    name: Package Lambda\n    runs-on: ubuntu-latest\n    needs: [lint, test]\n    steps:\n      - uses: actions/checkout@v4\n      \n      - name: Set up Python\n        uses: actions/setup-python@v5\n        with:\n          python-version: ${{ env.PYTHON_VERSION }}\n      \n      - name: Create deployment package\n        run: |\n          pip install -r requirements.txt -t package/\n          cp -r src/* package/\n          cd package && zip -r ../lambda_package.zip . && cd ..\n      \n      - name: Upload artifact\n        uses: actions/upload-artifact@v4\n        with:\n          name: lambda-package\n          path: lambda_package.zip\n          retention-days: 7\n\n  terraform-validate:\n    name: Terraform Validate\n    runs-on: ubuntu-latest\n    needs: package\n    steps:\n      - uses: actions/checkout@v4\n      \n      - name: Setup Terraform\n        uses: hashicorp/setup-terraform@v3\n        with:\n          terraform_version: 1.7.0\n      \n      - name: Download Lambda package\n        uses: actions/download-artifact@v4\n        with:\n          name: lambda-package\n      \n      - name: Terraform Format Check\n        working-directory: infra/terraform\n        run: terraform fmt -check -recursive\n      \n      - name: Terraform Init\n        working-directory: infra/terraform\n        run: |\n          terraform init -backend=false\n      \n      - name: Terraform Validate\n        working-directory: infra/terraform\n        run: terraform validate\n\n  terraform-plan:\n    name: Terraform Plan (Staging)\n    runs-on: ubuntu-latest\n    needs: terraform-validate\n    environment:\n      name: staging\n    steps:\n      - uses: actions/checkout@v4\n      \n      - name: Configure AWS Credentials\n        uses: aws-actions/configure-aws-credentials@v4\n        with:\n          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}\n          aws-region: ${{ env.AWS_REGION }}\n      \n      - name: Setup Terraform\n        uses: hashicorp/setup-terraform@v3\n        with:\n          terraform_version: 1.7.0\n      \n      - name: Download Lambda package\n        uses: actions/download-artifact@v4\n        with:\n          name: lambda-package\n      \n      - name: Terraform Init\n        working-directory: infra/terraform\n        run: |\n          terraform init \\\n            -backend-config=\"bucket=${{ secrets.TF_STATE_BUCKET }}\" \\\n            -backend-config=\"key=staging/terraform.tfstate\" \\\n            -backend-config=\"region=${{ env.AWS_REGION }}\" \\\n            -backend-config=\"dynamodb_table=${{ secrets.TF_LOCK_TABLE }}\"\n      \n      - name: Terraform Plan\n        id: plan\n        working-directory: infra/terraform\n        run: |\n          terraform plan \\\n            -var=\"project=${{ env.PROJECT_NAME }}\" \\\n            -var=\"env=staging\" \\\n            -var=\"region=${{ env.AWS_REGION }}\" \\\n            -out=tfplan\n      \n      - name: Upload plan\n        uses: actions/upload-artifact@v4\n        with:\n          name: terraform-plan\n          path: infra/terraform/tfplan\n          retention-days: 7\n      \n      - name: Comment PR\n        if: github.event_name == 'pull_request'\n        uses: actions/github-script@v7\n        with:\n          script: |\n            github.rest.issues.createComment({\n              issue_number: context.issue.number,\n              owner: context.repo.owner,\n              repo: context.repo.repo,\n              body: '✅ Terraform plan completed successfully for staging environment.'\n            })\n\n  terraform-apply:\n    name: Terraform Apply (Staging)\n    runs-on: ubuntu-latest\n    needs: terraform-plan\n    if: github.ref == 'refs/heads/main' && github.event_name == 'push'\n    environment:\n      name: staging\n    steps:\n      - uses: actions/checkout@v4\n      \n      - name: Configure AWS Credentials\n        uses: aws-actions/configure-aws-credentials@v4\n        with:\n          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}\n          aws-region: ${{ env.AWS_REGION }}\n      \n      - name: Setup Terraform\n        uses: hashicorp/setup-terraform@v3\n        with:\n          terraform_version: 1.7.0\n      \n      - name: Download Lambda package\n        uses: actions/download-artifact@v4\n        with:\n          name: lambda-package\n      \n      - name: Download plan\n        uses: actions/download-artifact@v4\n        with:\n          name: terraform-plan\n          path: infra/terraform/\n      \n      - name: Terraform Init\n        working-directory: infra/terraform\n        run: |\n          terraform init \\\n            -backend-config=\"bucket=${{ secrets.TF_STATE_BUCKET }}\" \\\n            -backend-config=\"key=staging/terraform.tfstate\" \\\n            -backend-config=\"region=${{ env.AWS_REGION }}\" \\\n            -backend-config=\"dynamodb_table=${{ secrets.TF_LOCK_TABLE }}\"\n      \n      - name: Terraform Apply\n        working-directory: infra/terraform\n        run: terraform apply -auto-approve tfplan\n      \n      - name: Output API Endpoint\n        working-directory: infra/terraform\n        run: |\n          echo \"API_ENDPOINT=$(terraform output -raw api_endpoint)\" >> $GITHUB_ENV\n      \n      - name: Deployment Summary\n        run: |\n          echo \"### Deployment Complete 🚀\" >> $GITHUB_STEP_SUMMARY\n          echo \"\" >> $GITHUB_STEP_SUMMARY\n          echo \"**Environment:** staging\" >> $GITHUB_STEP_SUMMARY\n          echo \"**API Endpoint:** ${{ env.API_ENDPOINT }}\" >> $GITHUB_STEP_SUMMARY\n          echo \"**Commit:** ${{ github.sha }}\" >> $GITHUB_STEP_SUMMARY\n"
      }
    ]
  },
  "ops": {
    "env_vars": {
      "orders_create": {
        "ORDERS_TABLE": "DynamoDB table name for orders",
        "EVENT_BUS_NAME": "EventBridge bus name for emitting events"
      },
      "orders_get": {
        "ORDERS_TABLE": "DynamoDB table name for orders"
      },
      "inventory_reserve": {
        "INVENTORY_TABLE": "DynamoDB table name for inventory and idempotency markers",
        "EVENT_BUS_NAME": "EventBridge bus name for emitting events"
      },
      "receipts_worker": {
        "EVENT_BUS_NAME": "EventBridge bus name (informational)"
      },
      "crm_ingestor": {
        "EVENT_BUS_NAME": "EventBridge bus name for emitting CustomerUpserted events"
      },
      "health": {
        "BUILD_SHA": "Git commit SHA for version tracking (optional)"
      }
    },
    "iam_policies": [
      {
        "name": "orders-lambda-ddb-access",
        "policy_json": "{\"Version\":\"2012-10-17\",\"Statement\":[{\"Effect\":\"Allow\",\"Action\":[\"dynamodb:PutItem\",\"dynamodb:GetItem\"],\"Resource\":\"<orders-table-arn>\"}]}"
      },
      {
        "name": "orders-lambda-events-access",
        "policy_json": "{\"Version\":\"2012-10-17\",\"Statement\":[{\"Effect\":\"Allow\",\"Action\":\"events:PutEvents\",\"Resource\":\"<event-bus-arn>\"}]}"
      },
      {
        "name": "inventory-lambda-ddb-access",
        "policy_json": "{\"Version\":\"2012-10-17\",\"Statement\":[{\"Effect\":\"Allow\",\"Action\":[\"dynamodb:PutItem\",\"dynamodb:UpdateItem\",\"dynamodb:GetItem\"],\"Resource\":\"<inventory-table-arn>\"}]}"
      },
      {
        "name": "inventory-lambda-events-access",
        "policy_json": "{\"Version\":\"2012-10-17\",\"Statement\":[{\"Effect\":\"Allow\",\"Action\":\"events:PutEvents\",\"Resource\":\"<event-bus-arn>\"}]}"
      },
      {
        "name": "ingestor-lambda-s3-access",
        "policy_json": "{\"Version\":\"2012-10-17\",\"Statement\":[{\"Effect\":\"Allow\",\"Action\":\"s3:GetObject\",\"Resource\":\"<crm-bucket-arn>/*\"}]}"
      },
      {
        "name": "ingestor-lambda-events-access",
        "policy_json": "{\"Version\":\"2012-10-17\",\"Statement\":[{\"Effect\":\"Allow\",\"Action\":\"events:PutEvents\",\"Resource\":\"<event-bus-arn>\"}]}"
      }
    ],
    "alarms": [
      {
        "name": "orders-create-errors",
        "description": "Alarm when orders create Lambda errors exceed 5 in 2 minutes"
      },
      {
        "name": "inventory-reserve-errors",
        "description": "Alarm when inventory reserve Lambda errors exceed 5 in 2 minutes"
      },
      {
        "name": "crm-ingestor-errors",
        "description": "Alarm when CRM ingestor Lambda errors exceed 3 in 5 minutes"
      },
      {
        "name": "orders-create-throttles",
        "description": "Alarm when orders create Lambda throttles exceed 10 in 1 minute"
      },
      {
        "name": "inventory-reserve-throttles",
        "description": "Alarm when inventory reserve Lambda throttles exceed 10 in 1 minute"
      },
      {
        "name": "api-5xx-errors",
        "description": "Alarm when API Gateway 5xx errors exceed 10 in 2 minutes"
      }
    ]
  },
  "readme.md": "# Serverless Backend System\n\n## Overview\n\nThis project implements a serverless backend system on AWS with the following capabilities:\n\n- **Orders Service**: Create and retrieve orders via HTTP API\n- **Receipts Worker**: Process order events asynchronously\n- **CRM Ingestion**: Parse CSV files from S3 and emit customer events\n- **Inventory Reservations**: Reserve inventory with idempotency and concurrency control\n\n## Architecture\n\n- **API Gateway (HTTP API)**: RESTful endpoints\n- **Lambda Functions**: Python 3.11 serverless compute\n- **DynamoDB**: NoSQL storage for orders and inventory