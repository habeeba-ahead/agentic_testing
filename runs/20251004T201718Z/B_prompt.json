```json
{
  "files": [
    {
      "path": "PATTERNS.md",
      "content": "# Terraform Patterns Library\n\nThis library provides reusable Terraform modules for AWS serverless infrastructure aligned with the Legacy Application Modernization architecture.\n\n## Modules\n\n### s3_bucket\nCreates an S3 bucket with encryption, versioning, lifecycle policies, and TLS enforcement.\n\n**Usage:**\n```hcl\nmodule \"app_storage\" {\n  source = \"./modules/s3_bucket\"\n  bucket_name = \"my-app-storage\"\n  enable_versioning = true\n  lifecycle_rules = [\n    {\n      id = \"archive-old-logs\"\n      enabled = true\n      transition_days = 90\n      storage_class = \"GLACIER\"\n    }\n  ]\n  force_ssl = true\n  kms_key_id = aws_kms_key.main.arn\n  tags = {\n    Environment = \"production\"\n    CostCenter = \"engineering\"\n    Application = \"core-app\"\n  }\n}\n```\n\n**Security Defaults:**\n- KMS encryption at rest (SSE-KMS)\n- TLS 1.2+ enforced via bucket policy when `force_ssl = true`\n- Public access blocked by default\n- Versioning enabled for data protection\n- Intelligent-Tiering for cost optimization\n\n### sqs_queue\nCreates an SQS queue with DLQ, encryption, and configurable message retention.\n\n**Usage:**\n```hcl\nmodule \"batch_queue\" {\n  source = \"./modules/sqs_queue\"\n  queue_name = \"batch-job-queue\"\n  visibility_timeout_seconds = 300\n  message_retention_seconds = 1209600\n  enable_dlq = true\n  max_receive_count = 3\n  kms_key_id = aws_kms_key.main.arn\n  tags = {\n    Environment = \"production\"\n    CostCenter = \"engineering\"\n    Application = \"batch-processing\"\n  }\n}\n```\n\n**Security Defaults:**\n- KMS encryption for messages at rest\n- Dead Letter Queue (DLQ) for failed messages\n- IAM-based access control (no public access)\n- Message retention configurable (default 14 days)\n\n### lambda_function\nCreates a Lambda function with IAM role, CloudWatch Logs, and X-Ray tracing.\n\n**Usage:**\n```hcl\nmodule \"api_handler\" {\n  source = \"./modules/lambda_function\"\n  function_name = \"core-api-handler\"\n  runtime = \"python3.11\"\n  handler = \"index.handler\"\n  source_code_path = \"./src/api_handler\"\n  timeout = 30\n  memory_size = 512\n  environment_variables = {\n    TABLE_NAME = aws_dynamodb_table.sessions.name\n    LOG_LEVEL = \"INFO\"\n  }\n  enable_xray = true\n  reserved_concurrent_executions = 100\n  vpc_config = {\n    subnet_ids = module.vpc.private_subnet_ids\n    security_group_ids = [aws_security_group.lambda.id]\n  }\n  tags = {\n    Environment = \"production\"\n    CostCenter = \"engineering\"\n    Application = \"core-app\"\n  }\n}\n```\n\n**Security Defaults:**\n- IAM role with least-privilege policies\n- CloudWatch Logs with 30-day retention\n- X-Ray tracing enabled for observability\n- VPC integration for private resource access\n- Reserved concurrency to prevent cost overruns\n- Environment variables encrypted at rest\n\n### apigw_http\nCreates an HTTP API Gateway with IAM authorization and CloudWatch logging.\n\n**Usage:**\n```hcl\nmodule \"core_api\" {\n  source = \"./modules/apigw_http\"\n  api_name = \"core-api\"\n  description = \"Core business logic API\"\n  cors_configuration = {\n    allow_origins = [\"https://app.example.com\"]\n    allow_methods = [\"GET\", \"POST\", \"PUT\", \"DELETE\"]\n    allow_headers = [\"Authorization\", \"Content-Type\"]\n    max_age = 300\n  }\n  routes = [\n    {\n      route_key = \"POST /orders\"\n      integration_uri = module.order_handler.lambda_invoke_arn\n      authorization_type = \"AWS_IAM\"\n    },\n    {\n      route_key = \"GET /orders/{id}\"\n      integration_uri = module.order_query.lambda_invoke_arn\n      authorization_type = \"AWS_IAM\"\n    }\n  ]\n  throttle_settings = {\n    rate_limit = 1000\n    burst_limit = 2000\n  }\n  enable_access_logs = true\n  tags = {\n    Environment = \"production\"\n    CostCenter = \"engineering\"\n    Application = \"core-app\"\n  }\n}\n```\n\n**Security Defaults:**\n- IAM authorization for all routes\n- TLS 1.2+ enforced\n- CloudWatch access logs enabled\n- Throttling configured to prevent abuse\n- CORS configured for controlled origins\n\n### vpc_minimal\nCreates a minimal VPC with public/private subnets, NAT Gateway, and VPC endpoints.\n\n**Usage:**\n```hcl\nmodule \"vpc\" {\n  source = \"./modules/vpc_minimal\"\n  vpc_name = \"app-vpc\"\n  cidr_block = \"10.0.0.0/16\"\n  availability_zones = [\"us-east-1a\", \"us-east-1b\", \"us-east-1c\"]\n  public_subnet_cidrs = [\"10.0.1.0/24\", \"10.0.2.0/24\", \"10.0.3.0/24\"]\n  private_subnet_cidrs = [\"10.0.11.0/24\", \"10.0.12.0/24\", \"10.0.13.0/24\"]\n  enable_nat_gateway = true\n  single_nat_gateway = false\n  enable_vpc_endpoints = true\n  vpc_endpoints = [\"s3\", \"dynamodb\", \"secretsmanager\"]\n  tags = {\n    Environment = \"production\"\n    CostCenter = \"engineering\"\n    Application = \"core-app\"\n  }\n}\n```\n\n**Security Defaults:**\n- Private subnets for compute resources\n- NAT Gateway for outbound internet access\n- VPC endpoints for AWS services (no internet egress)\n- Flow logs enabled for network monitoring\n- Network ACLs and security groups for defense in depth\n\n## Tagging Strategy\n\nAll modules enforce consistent tagging:\n- `Environment`: deployment stage (production, staging, dev)\n- `CostCenter`: business unit for cost allocation\n- `Application`: application identifier\n- `ManagedBy`: \"terraform\" (auto-applied)\n- `Compliance`: \"MEC\" for regulated workloads\n\n## Encryption Standards\n\n- **At Rest**: KMS customer-managed keys (CMKs) for S3, SQS, Lambda environment variables\n- **In Transit**: TLS 1.2+ enforced for all API endpoints and data transfers\n- **Secrets**: AWS Secrets Manager for credentials; no hardcoded values\n\n## Cost Optimization\n\n- S3 Intelligent-Tiering and Glacier lifecycle policies\n- Lambda reserved concurrency limits\n- DynamoDB on-demand mode (configured separately)\n- Aurora Serverless v2 auto-scaling (configured separately)\n- NAT Gateway consolidation option (single_nat_gateway flag)\n\n## Compliance\n\n- CloudTrail audit logging (configured at account level)\n- GuardDuty threat detection (configured at account level)\n- Security Hub compliance checks (configured at account level)\n- MEC alignment validated through tagging and encryption policies\n\n## Observability\n\n- CloudWatch Logs with structured JSON logging\n- X-Ray tracing for distributed request tracking\n- CloudWatch Metrics for all services\n- Alarms configured per SLA requirements (separate module)\n\n## Migration Patterns\n\n### Strangler Fig\nUse API Gateway and Lambda to incrementally replace on-prem endpoints:\n1. Route new traffic to Lambda handlers\n2. Proxy legacy traffic to on-prem via VPN\n3. Gradually migrate functionality\n4. Decommission on-prem services\n\n### Blue-Green Deployment\nUse Route 53 weighted routing:\n1. Deploy new infrastructure (green)\n2. Test with canary traffic\n3. Shift traffic incrementally\n4. Rollback via DNS if issues detected\n\n### Event-Driven Integration\nUse EventBridge and SQS for async workflows:\n1. Publish domain events from Lambda\n2. Decouple services via event subscriptions\n3. Enable retry and DLQ for resilience\n4. Scale consumers independently\n\n## Best Practices\n\n1. **Modularity**: Use modules for all resources; avoid inline definitions\n2. **Immutability**: Version modules; use semantic versioning\n3. **Testing**: Validate with `terraform plan` and automated tests\n4. **State Management**: Use S3 backend with DynamoDB locking\n5. **Secrets**: Never commit secrets; use Secrets Manager and IAM roles\n6. **Documentation**: Update README.md for each module change\n7. **Code Review**: Require peer review for all infrastructure changes\n8. **Drift Detection**: Run `terraform plan` regularly to detect manual changes\n\n## Support\n\nFor issues or questions, contact the platform engineering team or open a ticket in the infrastructure repository."
    },
    {
      "path": "modules/s3_bucket/main.tf",
      "content": "resource \"aws_s3_bucket\" \"this\" {\n  bucket = var.bucket_name\n  tags   = merge(var.tags, { ManagedBy = \"terraform\" })\n}\n\nresource \"aws_s3_bucket_versioning\" \"this\" {\n  bucket = aws_s3_bucket.this.id\n  versioning_configuration {\n    status = var.enable_versioning ? \"Enabled\" : \"Suspended\"\n  }\n}\n\nresource \"aws_s3_bucket_server_side_encryption_configuration\" \"this\" {\n  bucket = aws_s3_bucket.this.id\n  rule {\n    apply_server_side_encryption_by_default {\n      sse_algorithm     = \"aws:kms\"\n      kms_master_key_id = var.kms_key_id\n    }\n    bucket_key_enabled = true\n  }\n}\n\nresource \"aws_s3_bucket_public_access_block\" \"this\" {\n  bucket                  = aws_s3_bucket.this.id\n  block_public_acls       = true\n  block_public_policy     = true\n  ignore_public_acls      = true\n  restrict_public_buckets = true\n}\n\nresource \"aws_s3_bucket_lifecycle_configuration\" \"this\" {\n  count  = length(var.lifecycle_rules) > 0 ? 1 : 0\n  bucket = aws_s3_bucket.this.id\n\n  dynamic \"rule\" {\n    for_each = var.lifecycle_rules\n    content {\n      id     = rule.value.id\n      status = rule.value.enabled ? \"Enabled\" : \"Disabled\"\n\n      dynamic \"transition\" {\n        for_each = rule.value.transition_days != null ? [1] : []\n        content {\n          days          = rule.value.transition_days\n          storage_class = rule.value.storage_class\n        }\n      }\n\n      dynamic \"expiration\" {\n        for_each = rule.value.expiration_days != null ? [1] : []\n        content {\n          days = rule.value.expiration_days\n        }\n      }\n    }\n  }\n}\n\nresource \"aws_s3_bucket_intelligent_tiering_configuration\" \"this\" {\n  count  = var.enable_intelligent_tiering ? 1 : 0\n  bucket = aws_s3_bucket.this.id\n  name   = \"EntireBucket\"\n\n  tiering {\n    access_tier = \"ARCHIVE_ACCESS\"\n    days        = 90\n  }\n\n  tiering {\n    access_tier = \"DEEP_ARCHIVE_ACCESS\"\n    days        = 180\n  }\n}\n\nresource \"aws_s3_bucket_policy\" \"force_ssl\" {\n  count  = var.force_ssl ? 1 : 0\n  bucket = aws_s3_bucket.this.id\n  policy = jsonencode({\n    Version = \"2012-10-17\"\n    Statement = [\n      {\n        Sid       = \"DenyInsecureTransport\"\n        Effect    = \"Deny\"\n        Principal = \"*\"\n        Action    = \"s3:*\"\n        Resource = [\n          aws_s3_bucket.this.arn,\n          \"${aws_s3_bucket.this.arn}/*\"\n        ]\n        Condition = {\n          Bool = {\n            \"aws:SecureTransport\" = \"false\"\n          }\n        }\n      }\n    ]\n  })\n}\n\nresource \"aws_s3_bucket_logging\" \"this\" {\n  count         = var.logging_bucket != null ? 1 : 0\n  bucket        = aws_s3_bucket.this.id\n  target_bucket = var.logging_bucket\n  target_prefix = \"${var.bucket_name}/\"\n}"
    },
    {
      "path": "modules/s3_bucket/variables.tf",
      "content": "variable \"bucket_name\" {\n  description = \"Name of the S3 bucket\"\n  type        = string\n}\n\nvariable \"enable_versioning\" {\n  description = \"Enable versioning for the bucket\"\n  type        = bool\n  default     = true\n}\n\nvariable \"kms_key_id\" {\n  description = \"KMS key ID for bucket encryption\"\n  type        = string\n}\n\nvariable \"lifecycle_rules\" {\n  description = \"List of lifecycle rules for the bucket\"\n  type = list(object({\n    id               = string\n    enabled          = bool\n    transition_days  = optional(number)\n    storage_class    = optional(string)\n    expiration_days  = optional(number)\n  }))\n  default = []\n}\n\nvariable \"enable_intelligent_tiering\" {\n  description = \"Enable S3 Intelligent-Tiering\"\n  type        = bool\n  default     = true\n}\n\nvariable \"force_ssl\" {\n  description = \"Enforce TLS for all bucket operations\"\n  type        = bool\n  default     = true\n}\n\nvariable \"logging_bucket\" {\n  description = \"S3 bucket for access logs\"\n  type        = string\n  default     = null\n}\n\nvariable \"tags\" {\n  description = \"Tags to apply to the bucket\"\n  type        = map(string)\n  default     = {}\n}"
    },
    {
      "path": "modules/s3_bucket/outputs.tf",
      "content": "output \"bucket_id\" {\n  description = \"The name of the bucket\"\n  value       = aws_s3_bucket.this.id\n}\n\noutput \"bucket_arn\" {\n  description = \"The ARN of the bucket\"\n  value       = aws_s3_bucket.this.arn\n}\n\noutput \"bucket_domain_name\" {\n  description = \"The bucket domain name\"\n  value       = aws_s3_bucket.this.bucket_domain_name\n}\n\noutput \"bucket_regional_domain_name\" {\n  description = \"The bucket region-specific domain name\"\n  value       = aws_s3_bucket.this.bucket_regional_domain_name\n}"
    },
    {
      "path": "modules/s3_bucket/README.md",
      "content": "# S3 Bucket Module\n\nCreates an S3 bucket with encryption, versioning, lifecycle policies, and TLS enforcement.\n\n## Features\n\n- KMS encryption at rest (SSE-KMS)\n- Versioning enabled by default\n- Public access blocked\n- TLS 1.2+ enforcement via bucket policy\n- Intelligent-Tiering for cost optimization\n- Lifecycle rules for archival and expiration\n- Access logging support\n\n## Usage\n\n```hcl\nmodule \"app_storage\" {\n  source = \"./modules/s3_bucket\"\n  \n  bucket_name           = \"my-app-storage-prod\"\n  enable_versioning     = true\n  kms_key_id            = aws_kms_key.main.arn\n  force_ssl             = true\n  enable_intelligent_tiering = true\n  \n  lifecycle_rules = [\n    {\n      id              = \"archive-old-logs\"\n      enabled         = true\n      transition_days = 90\n      storage_class   = \"GLACIER\"\n    },\n    {\n      id              = \"delete-temp-files\"\n      enabled         = true\n      expiration_days = 30\n    }\n  ]\n  \n  logging_bucket = \"my-logging-bucket\"\n  \n  tags = {\n    Environment = \"production\"\n    CostCenter  = \"engineering\"\n    Application = \"core-app\"\n    Compliance  = \"MEC\"\n  }\n}\n```\n\n## Inputs\n\n| Name | Description | Type | Default | Required |\n|------|-------------|------|---------|----------|\n| bucket_name | Name of the S3 bucket | string | - | yes |\n| enable_versioning | Enable versioning for the bucket | bool | true | no |\n| kms_key_id | KMS key ID for bucket encryption | string | - | yes |\n| lifecycle_rules | List of lifecycle rules | list(object) | [] | no |\n| enable_intelligent_tiering | Enable S3 Intelligent-Tiering | bool | true | no |\n| force_ssl | Enforce TLS for all bucket operations | bool | true | no |\n| logging_bucket | S3 bucket for access logs | string | null | no |\n| tags | Tags to apply to the bucket | map(string) | {} | no |\n\n## Outputs\n\n| Name | Description |\n|------|-------------|\n| bucket_id | The name of the bucket |\n| bucket_arn | The ARN of the bucket |\n| bucket_domain_name | The bucket domain name |\n| bucket_regional_domain_name | The bucket region-specific domain name |\n\n## Security\n\n- All data encrypted at rest using KMS customer-managed keys\n- TLS 1.2+ enforced for all operations when `force_ssl = true`\n- Public access blocked by default\n- Versioning enabled to protect against accidental deletion\n- Access logging available for audit trails\n\n## Cost Optimization\n\n- Intelligent-Tiering automatically moves objects to cost-effective storage classes\n- Lifecycle rules transition old data to Glacier or delete temporary files\n- Bucket key enabled to reduce KMS API costs\n\n## Compliance\n\n- Supports MEC compliance through encryption and access controls\n- CloudTrail logs all API calls for audit purposes\n- Versioning provides data protection and recovery capabilities\n\n## Examples\n\n### Basic Bucket\n\n```hcl\nmodule \"basic_bucket\" {\n  source      = \"./modules/s3_bucket\"\n  bucket_name = \"my-basic-bucket\"\n  kms_key_id  = aws_kms_key.main.arn\n  tags = {\n    Environment = \"dev\"\n  }\n}\n```\n\n### Bucket with Lifecycle Rules\n\n```hcl\nmodule \"archive_bucket\" {\n  source      = \"./modules/s3_bucket\"\n  bucket_name = \"my-archive-bucket\"\n  kms_key_id  = aws_kms_key.main.arn\n  \n  lifecycle_rules = [\n    {\n      id              = \"archive-after-30-days\"\n      enabled         = true\n      transition_days = 30\n      storage_class   = \"GLACIER\"\n    },\n    {\n      id              = \"deep-archive-after-90-days\"\n      enabled         = true\n      transition_days = 90\n      storage_class   = \"DEEP_ARCHIVE\"\n    }\n  ]\n  \n  tags = {\n    Environment = \"production\"\n    Purpose     = \"long-term-archive\"\n  }\n}\n```"
    },
    {
      "path": "modules/sqs_queue/main.tf",
      "content": "resource \"aws_sqs_queue\" \"this\" {\n  name                       = var.queue_name\n  visibility_timeout_seconds = var.visibility_timeout_seconds\n  message_retention_seconds  = var.message_retention_seconds\n  max_message_size           = var.max_message_size\n  delay_seconds              = var.delay_seconds\n  receive_wait_time_seconds  = var.receive_wait_time_seconds\n  \n  kms_master_key_id                 = var.kms_key_id\n  kms_data_key_reuse_period_seconds = 300\n  \n  redrive_policy = var.enable_dlq ? jsonencode({\n    deadLetterTargetArn = aws_sqs_queue.dlq[0].arn\n    maxReceiveCount     = var.max_receive_count\n  }) : null\n  \n  tags = merge(var.tags, { ManagedBy = \"terraform\" })\n}\n\nresource \"aws_sqs_queue\" \"dlq\" {\n  count                     = var.enable_dlq ? 1 : 0\n  name                      = \"${var.queue_name}-dlq\"\n  message_retention_seconds = var.dlq_message_retention_seconds\n  \n  kms_master_key_id                 = var.kms_key_id\n  kms_data_key_reuse_period_seconds = 300\n  \n  tags = merge(var.tags, { ManagedBy = \"terraform\", Purpose = \"dead-letter-queue\" })\n}\n\nresource \"aws_sqs_queue_policy\" \"this\" {\n  count     = var.queue_policy != null ? 1 : 0\n  queue_url = aws_sqs_queue.this.id\n  policy    = var.queue_policy\n}\n\nresource \"aws_cloudwatch_